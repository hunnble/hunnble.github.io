<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>北方公园</title>
  <subtitle>Web/书和思考/一派胡言</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hunnble.github.io/"/>
  <updated>2018-07-25T15:38:36.000Z</updated>
  <id>http://hunnble.github.io/</id>
  
  <author>
    <name>Noski</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>首屏优化部分知识点</title>
    <link href="http://hunnble.github.io/2018/07/25/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://hunnble.github.io/2018/07/25/首屏优化部分知识点/</id>
    <published>2018-07-25T14:31:10.000Z</published>
    <updated>2018-07-25T15:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前对体验优化方面深入了解的不多，最近打算系统地学习一下这方面的知识，今天先总结一些首屏优化相关的知识点。</p>
<a id="more"></a>
<p>首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。<br>一些优化手段：</p>
<ul>
<li>skeleton screen（骨架屏）：在加载完成前使用图形进行占位，在加载完成后换成真实的内容</li>
<li>交互优化：加载完成前显示一个菊花什么的，和骨架屏一样都是比较直接地提升用户体验</li>
<li>路由懒加载：代码分拆打包，按路由来加载代码块</li>
<li>渐进式预加载，并行加载资源和数据</li>
<li>服务端渲染，同构直出，即使是部分同构</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前对体验优化方面深入了解的不多，最近打算系统地学习一下这方面的知识，今天先总结一些首屏优化相关的知识点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>新的结束和新的开始</title>
    <link href="http://hunnble.github.io/2018/07/13/%E6%96%B0%E7%9A%84%E7%BB%93%E6%9D%9F%E5%92%8C%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://hunnble.github.io/2018/07/13/新的结束和新的开始/</id>
    <published>2018-07-13T15:57:15.000Z</published>
    <updated>2018-07-25T15:37:49.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>写下这段话的时候听的歌是《OGNI COSA》，很好听，中文名字是《每一件事》<br>感觉自己以前有很多好的机遇没有把握住，之前听别人说人生不如意十之八九，也不知道是骗人的还是真的。反正我觉得我不如意的事情最多十之一二，但是还是会很遗憾。遗憾大多不是希望没发生的事情发生，而是希望有些事情当初没有做或者做得成熟一些。<br>有的人缅怀过去是因为对现状的不满，我倒是没有不满，因为对自己的期望一直不高，所以相当满意现在的状况了。最近想把霍乱时期的爱情看完，爸妈来看我的时候好好陪陪他们，工作别出什么差错，至于以后会对现在有什么遗憾，还是和过去一样留到以后吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;写下这段话的时候听的歌是《OGNI COSA》，很好听，中文名字是《每一件事》&lt;br&gt;感觉自己以前有很多好的机遇没有把握住，之前听别人说人生不如意十之八九，也不知道是骗人的还是真的。反正我觉得我不如意的事情最多十之一二，但是还是会很遗憾。
    
    </summary>
    
    
      <category term="啥也不是" scheme="http://hunnble.github.io/tag/%E5%95%A5%E4%B9%9F%E4%B8%8D%E6%98%AF/"/>
    
  </entry>
  
  <entry>
    <title>一种让自己专注的好办法</title>
    <link href="http://hunnble.github.io/2018/07/02/%E4%B8%80%E7%A7%8D%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B8%93%E6%B3%A8%E7%9A%84%E5%A5%BD%E5%8A%9E%E6%B3%95/"/>
    <id>http://hunnble.github.io/2018/07/02/一种让自己专注的好办法/</id>
    <published>2018-07-02T07:46:09.000Z</published>
    <updated>2018-07-02T07:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>用尖的那个牙咬舌尖，注意力就会特别集中，亲测有效</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用尖的那个牙咬舌尖，注意力就会特别集中，亲测有效&lt;/p&gt;

    
    </summary>
    
    
      <category term="啥也不是" scheme="http://hunnble.github.io/tag/%E5%95%A5%E4%B9%9F%E4%B8%8D%E6%98%AF/"/>
    
  </entry>
  
  <entry>
    <title>提前总结一下2017年</title>
    <link href="http://hunnble.github.io/2017/11/15/%E6%8F%90%E5%89%8D%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B2017%E5%B9%B4/"/>
    <id>http://hunnble.github.io/2017/11/15/提前总结一下2017年/</id>
    <published>2017-11-15T12:48:17.000Z</published>
    <updated>2018-07-02T07:47:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.发现了更多自己不擅长做的事<br>2.赚钱，花更多的钱<br>3.有一段时间没有自我驱动学习，因为忙着做不擅长做的东西，看来选择很重要</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.发现了更多自己不擅长做的事&lt;br&gt;2.赚钱，花更多的钱&lt;br&gt;3.有一段时间没有自我驱动学习，因为忙着做不擅长做的东西，看来选择很重要&lt;/p&gt;

    
    </summary>
    
    
      <category term="啥也不是" scheme="http://hunnble.github.io/tag/%E5%95%A5%E4%B9%9F%E4%B8%8D%E6%98%AF/"/>
    
  </entry>
  
  <entry>
    <title>Fiber</title>
    <link href="http://hunnble.github.io/2017/08/13/%E5%BC%82%E6%AD%A5/"/>
    <id>http://hunnble.github.io/2017/08/13/异步/</id>
    <published>2017-08-13T05:36:14.000Z</published>
    <updated>2017-08-13T08:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着React 16-beta的正式发布，Fiber这一概念进入很多前端工程师的视角，那么，Fiber究竟是什么？</p>
<a id="more"></a>
<h3 id="Fiber-纤程"><a href="#Fiber-纤程" class="headerlink" title="Fiber(纤程)"></a>Fiber(纤程)</h3><p>在操作系统层面，coroutines和fibers是一个概念，只不过fibers是在windows下的实现。二者都是用户控制切换，且能自动保存上下文状态，切换之间可以通过参数通信。下文fibers统称纤程。<br>纤程和线程的区别较大，纤程更为轻量级，一个线程可以包含一个或多个纤程；内核会对线程进行抢占式调度，所以线程一次只能执行一个纤程。<br>我的理解是，Fiber可以看做coroutines，或者可以理解为程序员而不是VM管理的线程。</p>
<h3 id="Fiber-in-Ruby"><a href="#Fiber-in-Ruby" class="headerlink" title="Fiber in Ruby"></a>Fiber in Ruby</h3><p>Fiber在Ruby1.9之后引入，举个栗子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">nums = Fiber.new <span class="keyword">do</span></div><div class="line">  num = <span class="number">2</span></div><div class="line">  loop <span class="keyword">do</span></div><div class="line">    Fiber.<span class="keyword">yield</span>(num) <span class="keyword">unless</span> num % <span class="number">3</span> == <span class="number">0</span></div><div class="line">    num += <span class="number">2</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="number">10</span>.times &#123; p nums.resume &#125;</div></pre></td></tr></table></figure>
<p>这个栗子做的事情是产生前十个可以被2整除但是不能被3整除的数，其中用到了Fiber。<br>Fiber的构造方法接受代码块，返回的是一个Fiber实例，这个代码块中的代码不会立即执行，而会在Fiber实例调用resume方法时执行，而在yield方法被调用时，当前执行将被挂起，把控制权交回调用resume时的代码，上一次resume方法的返回值是yield传入的值，在上面的代码中就是num。当返回值是nil时，将抛出FiberError。<br>具体应用见<a href="https://ruby-doc.org/core-2.2.0/Fiber.html" target="_blank" rel="external">文档</a></p>
<h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><p>进入正题，现在来介绍React Fiber。</p>
<h4 id="为什么需要它"><a href="#为什么需要它" class="headerlink" title="为什么需要它"></a>为什么需要它</h4><p>在现有React中，更新过程是同步的，无法暂停。所以当组件树很庞大的时候，更新组件树会占用浏览器唯一的线程直到更新操作完成，所以有时会有卡顿的感觉。这种情况通常发生在组件层级较深，更新时React的调用栈也很深的情况下。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>通过上文的对比，我们了解到纤程比线程要“细”的多，也就是说，它是一种更精密的并发处理机制。纤程可以帮助框架将更新操作进行分片，分片的目的是在每个小片进行完之后可以暂停，将浏览器线程出让，以便其他任务运行。<br>为了实现这种处理机制，React重新实现了Component渲染函数的调用栈，叫做虚拟调用栈(virtual call stack)，每个fiber可以看做一个虚拟栈帧(virtual stack frame)，我们都知道，React的渲染机制满足view = f(data)，那么在渲染函数被调用时会将fiber压栈，这个fiber代表的事务(执行计算和更新状态的单元)是可以暂停/复用/通过设置优先级来决定调用顺序的。于是渲染可以被理解为动态变化的fiber链表，可以做到高度的可控。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着React 16-beta的正式发布，Fiber这一概念进入很多前端工程师的视角，那么，Fiber究竟是什么？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6 class实现私有方法</title>
    <link href="http://hunnble.github.io/2017/06/09/ES6-class%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/"/>
    <id>http://hunnble.github.io/2017/06/09/ES6-class实现私有方法/</id>
    <published>2017-06-09T09:18:14.000Z</published>
    <updated>2018-07-25T15:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6中的<code>class</code>是没有<code>private</code>、<code>protected</code>和<code>public</code>关键字的，也就是说，在语法层面直接对<code>class</code>进行访问权限控制是无法做到的。这篇文章会介绍一些可行的解决方法。</p>
<a id="more"></a>
<h3 id="简单解决方法"><a href="#简单解决方法" class="headerlink" title="简单解决方法"></a>简单解决方法</h3><p>如果只考虑访问权限的限制，可以使用如下的解决方案</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> privateMethods = &#123;</div><div class="line">  privateMethod () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.say);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.say = <span class="string">"Hello"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  publicMethod() &#123;</div><div class="line">    privateMethods.privateMethod.call(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，在外部维护所谓的<code>private</code>方法，然后在使用时通过<code>call/apply</code>来把<code>this</code>绑定到类的实例上。这是一种丑陋的解决方案，因为<code>privateMethods</code>根本不是<code>Service</code>类的方法，只是在调用的时候通过额外的代码使其能访问到自己。然而，如果一个东西走起来像鸭子，叫起来也像鸭子，那么它就是鸭子，这种方案是可行的。</p>
<h3 id="更好地方案：使用ES6的Symbol"><a href="#更好地方案：使用ES6的Symbol" class="headerlink" title="更好地方案：使用ES6的Symbol"></a>更好地方案：使用ES6的Symbol</h3><p>我们来仔细思考一下，我们要做出来的这个东西有哪些要求？</p>
<p>1.外部不可访问<br>2.内部可以访问</p>
<p>好的，问题分解了，完美。接下来考虑怎么实现？在标题那里已经剧透了，用<code>Symbol</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> privateMethod = <span class="built_in">Symbol</span>(<span class="string">'privateMethod'</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="keyword">this</span>.say = <span class="string">"Hello"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  [privateMethod] () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.say);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  publicMethod () &#123;</div><div class="line">    <span class="keyword">this</span>[privateMethod]()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Uncaught TypeError: (intermediate value).privateMethod is not a function</span></div><div class="line"><span class="keyword">new</span> Service().privateMethod()</div><div class="line"></div><div class="line"><span class="comment">// Uncaught TypeError: (intermediate value)[Symbol(...)] is not a function</span></div><div class="line"><span class="keyword">new</span> Service()[<span class="built_in">Symbol</span>(<span class="string">'privateMethod'</span>)]();</div><div class="line"></div><div class="line"><span class="comment">// log: Hello</span></div><div class="line">newService().publicMethod()</div></pre></td></tr></table></figure></p>
<p>在要求1中，外部不可访问的实现通过<code>Symbol</code>自身的特性完美解决，首先，使用<code>Symbol</code>做私有方法的实际<code>name</code>属性，可以在外部访问<code>privateMethod</code>时隐藏实际的函数；其次，<code>Symbol</code>具有唯一性，可以确保同样的初始私有方法名不会被重复使用。</p>
<h3 id="同样的思路，另一种数据结构：WeakMap"><a href="#同样的思路，另一种数据结构：WeakMap" class="headerlink" title="同样的思路，另一种数据结构：WeakMap"></a>同样的思路，另一种数据结构：WeakMap</h3><p>使用同样的思路封装私有方法：将它们包在<code>WeakMap</code>中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> privateMethods = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="keyword">this</span>.say = <span class="string">"Hello"</span>;</div><div class="line">    privateMethods.set(<span class="keyword">this</span>, &#123;</div><div class="line">    	<span class="attr">privateMethod</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.say)</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  publicMethod() &#123;</div><div class="line">    privateMethods.get(<span class="keyword">this</span>).privateMethod();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Service().publicMethod();</div></pre></td></tr></table></figure>
<p>原理几乎一样，值得用一句话说一下的就是为什么用<code>WeakMap</code>而不是<code>Map</code>： 一个仅被<code>WeakMap</code>作为key引用的对象，会被垃圾回收器回收掉。</p>
<h3 id="还有哪些可行的方案？"><a href="#还有哪些可行的方案？" class="headerlink" title="还有哪些可行的方案？"></a>还有哪些可行的方案？</h3><p>在stackoverflow上浏览的时候还看到一种利用<code>Object.defineProperty</code>的解决方法，因为这种方法过于繁琐所以就不介绍了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6中的&lt;code&gt;class&lt;/code&gt;是没有&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;和&lt;code&gt;public&lt;/code&gt;关键字的，也就是说，在语法层面直接对&lt;code&gt;class&lt;/code&gt;进行访问权限控制是无法做到的。这篇文章会介绍一些可行的解决方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
  </entry>
  
  <entry>
    <title>koa源码分析</title>
    <link href="http://hunnble.github.io/2017/05/06/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://hunnble.github.io/2017/05/06/koa源码分析/</id>
    <published>2017-05-06T02:10:18.000Z</published>
    <updated>2018-07-25T15:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对Node.js框架koa部分源码的分析，如有错误欢迎指正。</p>
<a id="more"></a>
<h3 id="从构造函数开始"><a href="#从构造函数开始" class="headerlink" title="从构造函数开始"></a>从构造函数开始</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line">  <span class="keyword">super</span>();</div><div class="line">  <span class="keyword">this</span>.proxy = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">this</span>.middleware = [];</div><div class="line">  <span class="keyword">this</span>.subdomainOffset = <span class="number">2</span>;</div><div class="line">  <span class="keyword">this</span>.env = process.env.NODE_ENV || <span class="string">'development'</span>;</div><div class="line">  <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</div><div class="line">  <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</div><div class="line">  <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>koa的Application类继承了events模块，在构造函数中做了这些事情：</p>
<ul>
<li>默认不设置代理</li>
<li>middleware是中间件数组</li>
<li>子域名偏移量默认为2，也就是默认忽略数量为2</li>
<li>环境变量的处理</li>
<li>挂载context、request、response</li>
</ul>
<h3 id="服务器的启动"><a href="#服务器的启动" class="headerlink" title="服务器的启动"></a>服务器的启动</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">listen(...args) &#123;</div><div class="line">  <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</div><div class="line">  <span class="keyword">return</span> server.listen(...args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用Node.js的http模块来创建一个服务器，具体的handle是使用callback方法的返回值。最后将listen函数的参数透传到创建好的服务器实例的listen方法中完成服务器的启动。</p>
<h3 id="请求的处理"><a href="#请求的处理" class="headerlink" title="请求的处理"></a>请求的处理</h3><p>下面来分析刚刚说过的callback方法，我们已经知道，它的返回值是一个交付给http模块的server实例的请求处理(request handler)函数，下面来看实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">callback() &#123;</div><div class="line">  <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners(<span class="string">'error'</span>).length) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    res.statusCode = <span class="number">404</span>;</div><div class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</div><div class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</div><div class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</div><div class="line">    onFinished(res, onerror);</div><div class="line">    <span class="keyword">return</span> fn(ctx).then(handleResponse).catch(onerror);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> handleRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用koa-compose模块组合中间件-gt-中间件机制"><a href="#使用koa-compose模块组合中间件-gt-中间件机制" class="headerlink" title="使用koa-compose模块组合中间件 -&gt; 中间件机制"></a>使用koa-compose模块组合中间件 -&gt; 中间件机制</h4><p>koa的中间件遵循流水线模式，多个中间件依次输入，之后倒序执行，也就是官方的那张洋葱图。</p>
<p><img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt="执行顺序"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</div><div class="line">  <span class="comment">// 这里对middleware的类型和每一个中间件的类型做了判断</span></div><div class="line">  <span class="comment">// 话说js类型系统是一大黑点啊</span></div><div class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></div><div class="line">    <span class="comment">// 递归调用dispatch，每一次在调用async next()时都resolve一个中间件，最后倒序执行每一个函数体后面的代码。</span></div><div class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</div><div class="line">      index = i</div><div class="line">      <span class="keyword">let</span> fn = middleware[i]</div><div class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</div><div class="line">      <span class="comment">// 返回Promise实例，使后面的逻辑可以执行</span></div><div class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> dispatch(i + <span class="number">1</span>)</div><div class="line">        &#125;))</div><div class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="handleRequest"><a href="#handleRequest" class="headerlink" title="handleRequest"></a>handleRequest</h4><ul>
<li>通过createContext方法得到ctx，也就是context对象，它把request和response的一些方法代理到自己身上</li>
<li>onerror: 可以监听全局错误，包含了一些基本的异常处理，具体的代码是在源码的context.js中</li>
<li>handleResponse处理response</li>
<li>用on-finished模块+刚才说的onerror来捕获和处理异常</li>
</ul>
<h3 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h3><p>koa中，使用中间件非常方便，只需要写类似的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">  <span class="keyword">await</span> next();</div><div class="line">  <span class="keyword">const</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span>() - start;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>`</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>use方法接受一个函数参数， 返回app实例自身，所以可以链式地写一长串。下面分析一下use方法的源码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use(fn) &#123;</div><div class="line">  <span class="comment">// 又见类型检测...</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'middleware must be a function!'</span>);</div><div class="line">  <span class="comment">// 这里我删掉一段判断Generator函数的代码，众所周知，koa1是基于generator和co的，而koa2换成了async await的语法糖</span></div><div class="line">  <span class="keyword">this</span>.middleware.push(fn);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>哈，其实就是简单地往middleware数组push了中间件而已，很简单。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对Node.js框架koa部分源码的分析，如有错误欢迎指正。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://hunnble.github.io/tag/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的装饰器</title>
    <link href="http://hunnble.github.io/2016/12/26/JavaScript%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://hunnble.github.io/2016/12/26/JavaScript中的装饰器/</id>
    <published>2016-12-26T14:55:19.000Z</published>
    <updated>2018-07-25T15:37:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你学过<code>python</code>，一定对装饰器已经很熟悉了，在新标准下，<code>JavaScript</code>也支持了装饰器语法。如果你没有使用过装饰器，希望这篇文章可以带你入门。</p>
<a id="more"></a>
<h3 id="我们所熟知的Python中的装饰器"><a href="#我们所熟知的Python中的装饰器" class="headerlink" title="我们所熟知的Python中的装饰器"></a>我们所熟知的Python中的装饰器</h3><p>装饰器装饰的是谁？是函数。<br>装饰器长什么样子？以<code>@</code>开头，接着是装饰器函数的名字和参数（可选），接下来是被修饰的函数和被修饰函数的参数。举个栗子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator(dec_opt_args)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcBeDecorated</span><span class="params">(func_opt_args)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>至于装饰器解决了什么问题，以及有参数无参数的装饰器的区别，我觉得下面的代码可以解释清楚：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator1</span></div><div class="line"><span class="meta">@decorator2(args)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>可以理解为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func = decorator1(decorator2(args)(func))</div></pre></td></tr></table></figure></p>
<p>也就是说，装饰器其实就是函数，被装饰的函数把自己当做中世纪农夫的新娘一样，作为参数献给装饰器（们），在装饰器行使了自己的权利（参数）之后，返回被装饰过了的函数对象。<br>但是要注意，这个例子实际上是不恰当的，因为实际上装饰器是柳下惠在世，根本就没有改变被修饰的函数。只是<em>装饰</em>了函数，在函数上扩展一些行为。<br>此外，对类（class）也可以用装饰器，道理是一样的。<br>那么在<code>JavaScript</code>中的装饰器又有什么特性呢？</p>
<h3 id="JavaScript中的装饰器"><a href="#JavaScript中的装饰器" class="headerlink" title="JavaScript中的装饰器"></a>JavaScript中的装饰器</h3><p>先放结论：</p>
<blockquote>
<p>装饰器允许你在类和方法定义的时候去注释或者修改它。装饰器是一个作用于函数的表达式，它接收三个参数 <code>target</code>、 <code>name</code> 和 <code>descriptor</code> ， 然后可选性的返回被装饰之后的 <code>descriptor</code> 对象。<br><code>JavaScript</code>中的装饰器可以装饰类，也可以装饰类的属性，当它装饰类时，长这个样子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorator</span> (<span class="params">target</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(target) <span class="comment">// target是Component</span></div><div class="line">    <span class="keyword">return</span> target</div><div class="line">&#125;</div><div class="line"></div><div class="line">@decorator</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和上面说的<code>python</code>中的装饰器基本上差不多的样子<br>当装饰器装饰类的属性时，操作的不是类本身了，而是第三个参数：描述符。这也是为什么定义中说是可选性的返回被装饰之后的<code>descriptor</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorator</span> (<span class="params">target, name, descriptor</span>) </span>&#123;</div><div class="line">    discriptor.writable = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> discriptor;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    @decorator</div><div class="line">    play () &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'too young'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component();</div><div class="line">component.play = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'too simple'</span>);</div><div class="line">&#125;</div><div class="line">component.play() <span class="comment">// too young</span></div></pre></td></tr></table></figure></p>
<p>为什么对play属性的修改无效了呢？因为在装饰器中将被返回的描述符的play属性设置为只读，就这么简单。<br>随着JavaScript的完善，<del>它会越来越像python的</del> 好用的语法糖会越来越多的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你学过&lt;code&gt;python&lt;/code&gt;，一定对装饰器已经很熟悉了，在新标准下，&lt;code&gt;JavaScript&lt;/code&gt;也支持了装饰器语法。如果你没有使用过装饰器，希望这篇文章可以带你入门。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>记一个React相关的坑</title>
    <link href="http://hunnble.github.io/2016/12/13/%E8%AE%B0%E4%B8%80%E4%B8%AAReact%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9D%91/"/>
    <id>http://hunnble.github.io/2016/12/13/记一个React相关的坑/</id>
    <published>2016-12-13T07:45:11.000Z</published>
    <updated>2018-07-25T15:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>React写表单一直挺难受的，即使有react-form也很难受，不过优点太大把这点小瑕疵掩盖住了。不过今天我要记一下<code>redux-form-utils</code>的坑。</p>
<a id="more"></a>
<p>这个中间件开始用的时候很方便，可以用更少和更少重复的代码构建表单。不用给每个都加<code>onChange</code>。但是用了以后一直出bug，后来发现它的源码里只支持state里有一个formState，因为它是写死了的。<br>先看它的示例用法，我没复制写组件的那部分，那部分是无辜的：<br><figure class="highlight javascript"><figcaption><span>https://github.com/jasonslyvia/redux-form-utils</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; bindRedux &#125; <span class="keyword">from</span> <span class="string">'redux-form-utils'</span>;</div><div class="line"><span class="keyword">const</span> &#123; <span class="attr">state</span>: formState , <span class="attr">reducer</span>: formReducer, <span class="attr">actionCreators</span>: formActionCreators &#125; = bindRedux(&#123;</div><div class="line">    <span class="attr">form</span>: <span class="string">'my-form'</span>,</div><div class="line">    <span class="attr">fields</span>: [<span class="string">'name'</span>, <span class="string">'address'</span>]</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// `formState` has a shape of:</span></div><div class="line"><span class="comment">//  &#123;</span></div><div class="line"><span class="comment">//      form: &#123;</span></div><div class="line"><span class="comment">//          name: &#123;</span></div><div class="line"><span class="comment">//          value: '',</span></div><div class="line"><span class="comment">//      &#125;,</span></div><div class="line"><span class="comment">//      address: &#123;</span></div><div class="line"><span class="comment">//          value: '',</span></div><div class="line"><span class="comment">//      &#125;</span></div><div class="line"><span class="comment">//  &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// Compose initialState with formState</span></div><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</div><div class="line">    ...formState</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'XXX_ACTION'</span>: &#123;</div><div class="line">            <span class="comment">// Do sth for your own action</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">          <span class="comment">// Let formReducer handle default situation instead of returning state directly</span></div><div class="line">          <span class="keyword">return</span> formReducer(state, action);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>我想有多个formState的话肯定需要把state改成类似这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">formState1</span>: formState1,</div><div class="line">    <span class="attr">formState2</span>: formState2</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>我就这么改的，然后发现onChange就没有用了，输入也不会改变value。原因看源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">switch (action.type) &#123;</div><div class="line">    case &apos;@@form/VALUE_CHANGE&apos;: &#123;</div><div class="line">        const fieldConfig = findConfig(action.meta.field);</div><div class="line">        let newField;</div><div class="line">        if (action.meta.complex) &#123;</div><div class="line">            return &#123;</div><div class="line">                ...state,</div><div class="line">                form: &#123;</div><div class="line">                    ...state.form,</div><div class="line">                    [action.meta.field]: &#123;</div><div class="line">                        ...state.form[action.meta.field],</div><div class="line">                        ...action.payload,</div><div class="line">                    &#125;,</div><div class="line">                &#125;,</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这里截取了源码的reducer中的对value change这种action的响应，还有对action.meta的判断由于篇幅就没有截取全。<br>问题就在于它把返回的格式写死了，永远都是放到form了。<br>默默uninstall掉它，还是自己写吧…<br>由此可见还是自己把常用的一些轮子造好比较好</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React写表单一直挺难受的，即使有react-form也很难受，不过优点太大把这点小瑕疵掩盖住了。不过今天我要记一下&lt;code&gt;redux-form-utils&lt;/code&gt;的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>AppleScript实现hexo新建/发布工作流</title>
    <link href="http://hunnble.github.io/2016/12/08/AppleScript%E5%AE%9E%E7%8E%B0hexo%E6%96%B0%E5%BB%BA-%E5%8F%91%E5%B8%83%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://hunnble.github.io/2016/12/08/AppleScript实现hexo新建-发布工作流/</id>
    <published>2016-12-08T14:50:03.000Z</published>
    <updated>2018-07-25T15:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在折腾hexo主题，然后发现在OSX系统中可以用AppleScript脚本实现很多快捷的工作流小应用。所以花了半个下午在别人的基础上改写了两个AppleScript脚本实现hexo的快速部署。</p>
<a id="more"></a>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在没有脚本的情况下，用hexo新建一篇文章的流程是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">hexo new &quot;文章名&quot;</div><div class="line">...切换到命令行</div><div class="line">...切换到编辑器写文章</div><div class="line">...切换到命令行</div><div class="line">hexo clean</div><div class="line">hexo g</div><div class="line">gulp</div><div class="line">hexo d</div></pre></td></tr></table></figure></p>
<p>因为我用gulp压缩要发布的html,css,js,image所以不能直接<code>hexo d -g</code>这样。<br>这样太麻烦了，为了节省自己的时间，我如上文所说的那样花了半个下午去了解了一下AppleScript并且写了两个脚本。呃呃，不知道要写多少篇文章才能把半个下午节约回来…哈哈</p>
<h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo-new"></a>hexo-new</h3><p>下面是新建hexo的脚本，执行效果是弹出dialog，填写文章名后确认，自动打开Atom编辑器编辑文章。<br><figure class="highlight applescript"><figcaption><span>hexo-new</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Finder"</span></div><div class="line">	<span class="built_in">activate</span></div><div class="line">	<span class="built_in">display dialog</span> <span class="string">"填入文章标题"</span> default answer <span class="string">"title"</span></div><div class="line">	<span class="keyword">set</span> title <span class="keyword">to</span> <span class="built_in">text</span> returned <span class="keyword">of</span> <span class="literal">result</span> <span class="keyword">as</span> <span class="built_in">text</span></div><div class="line"><span class="keyword">end</span> <span class="keyword">tell</span></div><div class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Terminal"</span></div><div class="line">	<span class="built_in">activate</span></div><div class="line">	<span class="keyword">if</span> (<span class="built_in">count</span> <span class="keyword">of</span> windows) <span class="keyword">is</span> <span class="number">0</span> <span class="keyword">then</span></div><div class="line">		<span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"System Events"</span></div><div class="line">			keystroke <span class="string">"n"</span> using &#123;command down&#125;</div><div class="line">		<span class="keyword">end</span> <span class="keyword">tell</span></div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">activate</span></div><div class="line">	<span class="keyword">end</span> <span class="keyword">if</span></div><div class="line">	<span class="keyword">set</span> win <span class="keyword">to</span> window [<span class="number">0</span>]</div><div class="line">	<span class="keyword">set</span> currentTab <span class="keyword">to</span> selected <span class="literal">tab</span> <span class="keyword">of</span> win</div><div class="line">	do <span class="keyword">script</span> <span class="string">"cd ........../hexo_blog"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"hexo new "</span> &amp; title <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">1</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"open -a Atom source/_posts/"</span> &amp; title &amp; <span class="string">".md"</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">3</span></div><div class="line">	close windows</div><div class="line"><span class="keyword">end</span> <span class="keyword">tell</span></div></pre></td></tr></table></figure></p>
<h3 id="hexo-publish"><a href="#hexo-publish" class="headerlink" title="hexo-publish"></a>hexo-publish</h3><p>第二个是发布的脚本，执行效果是直接发布，什么都不用做，之后会自行关闭终端。<br><figure class="highlight applescript"><figcaption><span>hexo-publish</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Terminal"</span></div><div class="line">	<span class="built_in">activate</span></div><div class="line">	<span class="keyword">set</span> win <span class="keyword">to</span> window [<span class="number">0</span>]</div><div class="line">	<span class="keyword">set</span> currentTab <span class="keyword">to</span> selected <span class="literal">tab</span> <span class="keyword">of</span> win</div><div class="line">	do <span class="keyword">script</span> <span class="string">"cd ........../hexo_blog"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"hexo clean "</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">1</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"hexo g "</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="comment">-- 生成CNAME，供域名解析</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"cd public"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"touch CNAME"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"echo www.yoursite.com &gt; CNAME"</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">5</span></div><div class="line">	<span class="comment">-- 压缩</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"cd ../"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"gulp"</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">10</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"hexo d"</span> <span class="keyword">in</span> currentTab</div><div class="line">	close windows</div><div class="line"><span class="keyword">end</span> <span class="keyword">tell</span></div></pre></td></tr></table></figure></p>
<p>根据自己的需求加上gulp的调用和CNAME文件的写入。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>脚本写完之后保存的默认格式是scpt，另存为app就可以用Alfred或者spotlight或者放Dock或者别的地方打开来完成hexo写博客并发布的工作流了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在折腾hexo主题，然后发现在OSX系统中可以用AppleScript脚本实现很多快捷的工作流小应用。所以花了半个下午在别人的基础上改写了两个AppleScript脚本实现hexo的快速部署。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://hunnble.github.io/tag/hexo/"/>
    
  </entry>
  
  <entry>
    <title>用JavaScript实现几种排序算法</title>
    <link href="http://hunnble.github.io/2016/11/05/%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://hunnble.github.io/2016/11/05/用JavaScript实现几种排序算法/</id>
    <published>2016-11-05T01:49:07.000Z</published>
    <updated>2018-07-25T15:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天周六，打算花一些时间把几种排序算法使用js实现一下。</p>
<a id="more"></a>
<h3 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h3><p>首先用mocha+chai写几行测试，然后测排序是不是正确就不用自己瞅了…以测试归并排序为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</div><div class="line"><span class="keyword">var</span> sortFuncs = <span class="built_in">require</span>(<span class="string">'./sort.js'</span>);</div><div class="line"></div><div class="line">describe(<span class="string">'sort function must be right'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    describe(<span class="string">'merge sort'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> arr = arrayGenerator(<span class="number">20</span>);</div><div class="line">        it(<span class="string">'merge sort should be correct'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            expect(sortFuncs.mergeSort(arr)).to.eql(sort(arr));</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayGenerator</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        arr.push(<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">100</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">v1, v2</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> v2 - v1;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成随机数组成的数组，然后去断言被测试的函数的排序结果是否和js的sort返回的正确结果一致。我今天写的所有排序都是从大到小哈。</p>
<h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h3><p>直接上代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">a1, a2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">var</span> a1Cursor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> a2Cursor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (a1Cursor &lt; a1.length &amp;&amp; a2Cursor &lt; a2.length) &#123;</div><div class="line">        <span class="keyword">if</span> (a1[a1Cursor] &gt; a2[a2Cursor]) &#123;</div><div class="line">            result.push(a1[a1Cursor]);</div><div class="line">            a1Cursor += <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(a2[a2Cursor]);</div><div class="line">            a2Cursor += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result.concat(a1.slice(a1Cursor)).concat(a2.slice(a2Cursor));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span> || arr.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> n = <span class="built_in">parseInt</span>(arr.length / <span class="number">2</span>, <span class="number">10</span>);</div><div class="line">    <span class="keyword">var</span> a1 = arr.slice(<span class="number">0</span>, n);</div><div class="line">    <span class="keyword">var</span> a2 = arr.slice(n);</div><div class="line">    <span class="keyword">return</span> merge(mergeSort(a1), mergeSort(a2));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个是用递归实现了的，虽然实现了但是需要花很多额外的空间。<br>小小优化一下，在合并函数中不额外创建新数组result，而是把a2合并到a1上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">a1, a2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a1Cursor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> a2Cursor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (a1Cursor &lt; a1.length &amp;&amp; a2Cursor &lt; a2.length) &#123;</div><div class="line">        <span class="keyword">if</span> (a1[a1Cursor] &lt; a2[a2Cursor]) &#123;</div><div class="line">            a1.splice(a1Cursor, <span class="number">0</span>, a2[a2Cursor]);</div><div class="line">            a2Cursor += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        a1Cursor += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> a1.concat(a2.slice(a2Cursor));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯…好一点了。<br>实现了自顶向下的归并，下面来实现自底向上的非递归版本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span> || arr.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> work = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        work.push([arr[i]]);</div><div class="line">    &#125;</div><div class="line">    work.push([]);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> lim = len; lim &gt; <span class="number">1</span>; lim = (lim + <span class="number">1</span>) / <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; lim; j += <span class="number">1</span>, k += <span class="number">2</span>)&#123;</div><div class="line">            work[j] = merge(work[k], work[k+<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        work[j] = [];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> work[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>思路很清晰，就是维护一个work数组，暂存分治的数组，自底向上合并。</p>
<h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h3><p>冒泡排序是把最大/小的元素冒泡到最后，快速排序是把比基准值(pivot)小的放一边，大的放一边，然后再分别排序。<br>上代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span> || arr.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> left = [];</div><div class="line">    <span class="keyword">var</span> right = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = arr.length; i &lt; len; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">0</span>]) &#123;</div><div class="line">            left.push(arr[i]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            right.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> quickSort(left).concat(arr[<span class="number">0</span>]).concat(quickSort(right));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h3><p>希尔排序就是给直接插入排序升级成隔很远的能更快比较的版本。间隔(gap)为1时就是直接插入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> gaps = [<span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>]; <span class="comment">// 间隔序列取10, 4, 1</span></div><div class="line">    <span class="keyword">var</span> arrLen = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, gapsLen = gaps.length; i &lt; gapsLen; ++i) &#123;</div><div class="line">        <span class="keyword">var</span> gap = gaps[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = gap; j &lt; arrLen; ++j) &#123;</div><div class="line">            <span class="keyword">var</span> tmp = arr[j];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> k = j; k &gt; gaps[i] &amp;&amp; arr[k - gap] &lt; tmp; k -= gap) &#123;</div><div class="line">                arr[k] = arr[k - gap];</div><div class="line">            &#125;</div><div class="line">            arr[k] = tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先这样，有空再更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天周六，打算花一些时间把几种排序算法使用js实现一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="算法" scheme="http://hunnble.github.io/tag/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AMD模块加载工具requirejs</title>
    <link href="http://hunnble.github.io/2016/11/02/AMD%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%B7%A5%E5%85%B7requirejs/"/>
    <id>http://hunnble.github.io/2016/11/02/AMD模块加载工具requirejs/</id>
    <published>2016-11-02T12:58:44.000Z</published>
    <updated>2018-07-25T15:35:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>苏子曰：<br>“客亦知夫水与月乎?逝者如斯,而未尝往也；<br>盈虚者如彼,而卒莫消长也。<br>盖将自其变者而观之,而天地曾不能一瞬；<br>自其不变者而观之,则物于我皆无尽也。<br>而又何羡乎?<br>且夫天地之间,物各有主。<br>苟非吾之所有,虽一毫而莫取。<br>惟江上之清风,与山间之明月,耳得之而为声,目遇之而成色。<br>取之无禁,用之不竭。<br>是造物者之无尽藏也,而吾与子之所共适.”</p>
</blockquote>
<a id="more"></a>
<p>虽然2016年大家都在用<code>webpack</code>、<code>react</code>、<code>vue</code>和<code>ng2</code>什么的，但是我还是炒一下<code>jquery</code>和<code>requirejs</code>的冷饭吧。这篇博客就说一下这个AMD模块加载方案工具<code>requirejs</code>。</p>
<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>和<a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="external">CMD</a>的介绍就不放这里了。CMD的加载方案有<code>sea.js</code>，是阿里做的一套方案，我没有用过，因为<code>requirejs</code>已经够用了，更何况学<code>ES6</code>和<code>react</code>之后其实还是用<code>webpack</code>比较多。话说前端的轮子实在多的不行，写这篇博客之前一搜模块加载方案搜出来好几页。还好加载机制只有AMD/CMD/UMD/CommonJS，了解这几种思想就不用怕了，万变不离其宗嘛。</p>
<p><code>requirejs</code>的功能是js脚本的模块化，一句话解释一下，就是用模块名称代替url来加载js脚本。使用<code>requirejs</code>后就可以把一堆<code>script</code>标签用一行代替：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">"入口模块"</span> <span class="attr">src</span>=<span class="string">"require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>而入口模块，比如是js/index.js，那么在index.js中就要对<code>requirejs</code>进行配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">requirejs.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>: <span class="string">'默认路径'</span>,</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="string">'jquery'</span>: <span class="string">'jquery.min.js'</span>,</div><div class="line">        ...</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">&#125;);</div><div class="line"></div><div class="line">requirejs([<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">start</span>) </span>&#123;</div><div class="line">    start();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里用<code>jquery</code>举例子，其实只要是js脚本就可以当做模块加载进来的。config里的配置选项还有很多。</p>
<p>那么只要在被加载的js文件中定义好模块就可以使用了，比如a.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        $(<span class="built_in">document</span>).ready(run());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 可以用$了，哈哈</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最简单地加载模块方式就是这样，代码不会比不使用<code>requirejs</code>多很多，看着也清楚多了（废话，模块化了总不会更乱吧）。<br><code>requirejs</code>是异步加载模块，这比较符合广大js程序员的思维方式，而且模块之间有依赖关系也可以显式地在define时的数组参数中写出，不会因为异步加载导致加载失败。而且文档也挺全的。我今天写一个只用<code>jquery</code>的东西，用<code>webpack</code>感觉很大材小用了，要是不想每次编译还要开个服务器做hot-reloader，所以就又用了一次<code>requirejs</code>，还是挺好用的，哈哈。<br>最后还是说一句，其实还是ES6的<code>import</code>/<code>export</code>用的最爽。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;苏子曰：&lt;br&gt;“客亦知夫水与月乎?逝者如斯,而未尝往也；&lt;br&gt;盈虚者如彼,而卒莫消长也。&lt;br&gt;盖将自其变者而观之,而天地曾不能一瞬；&lt;br&gt;自其不变者而观之,则物于我皆无尽也。&lt;br&gt;而又何羡乎?&lt;br&gt;且夫天地之间,物各有主。&lt;br&gt;苟非吾之所有,虽一毫而莫取。&lt;br&gt;惟江上之清风,与山间之明月,耳得之而为声,目遇之而成色。&lt;br&gt;取之无禁,用之不竭。&lt;br&gt;是造物者之无尽藏也,而吾与子之所共适.”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://hunnble.github.io/2016/08/17/%E9%97%AD%E5%8C%85/"/>
    <id>http://hunnble.github.io/2016/08/17/闭包/</id>
    <published>2016-08-17T03:52:05.000Z</published>
    <updated>2018-07-25T15:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章简单介绍闭包及在JavaScript语言中的应用</p>
<a id="more"></a>
<h2 id="离散数学中的闭包："><a href="#离散数学中的闭包：" class="headerlink" title="离散数学中的闭包："></a>离散数学中的闭包：</h2><p>包含指定集合的满足在某个运算下闭合的最小集合／如果集合A在某种操作作用下的结果仍然属于集合A，那么就认为集合A在这个操作下拥有闭包属性。也可以说，集合A在这个操作下是闭合的</p>
<h2 id="程序语言中的闭包："><a href="#程序语言中的闭包：" class="headerlink" title="程序语言中的闭包："></a>程序语言中的闭包：</h2><p>又叫词法闭包，或者函数闭包，指的是程序语言中的特性，具备该特性的程序语言能将函数和函数所处的环境当做整体使用。有时也把这个整体叫做闭包。</p>
<p><em>二者是不同的，这里说的是程序语言中的JavaScript中的闭包。JavaScript中的闭包指持有外部环境变量的函数。</em></p>
<h2 id="JavaScript中的闭包"><a href="#JavaScript中的闭包" class="headerlink" title="JavaScript中的闭包"></a>JavaScript中的闭包</h2><p>JavaScript闭包的本质源自两点，词法作用域和函数当作值传递。</p>
<h3 id="1-词法作用域"><a href="#1-词法作用域" class="headerlink" title="1.词法作用域"></a>1.词法作用域</h3><p>JavaScript的作用域链是指每一个函数内部不止可以访问它自己作用域中的变量，还可以访问包含它的函数作用域中的变量，一直上溯到全局变量，是为作用域链。</p>
<h3 id="2-函数当作值传递"><a href="#2-函数当作值传递" class="headerlink" title="2.函数当作值传递"></a>2.函数当作值传递</h3><p>JavaScript中函数是first-class的，可以被当做值来传递，一个函数可以return一个函数。</p>
<p><em>以上两点组成了形成闭包的条件，一言以蔽之，就是封闭外部作用域中一部分自由变量以及内部作用域，让内部作用域“记忆”外部状态。</em></p>
<p>看一个最简单的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">functionAdd(y)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> x + y</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对内部函数function(x)来讲，y就是自由变量，而且function(x)的返回值，依赖于这个外部自由变量y。而往上推一层，外围Add(y)函数正好就是那个包含自由变量y的环境。而且Javascript的语法允许内部函数function(x)访问外部函数Add(y)的局部变量。满足这三个条件，所以这个时候，外部函数Add(y)对内部函数function(x)构成了闭包。</p>
<h2 id="常见例子："><a href="#常见例子：" class="headerlink" title="常见例子："></a>常见例子：</h2><h3 id="1-调用函数里面的函数"><a href="#1-调用函数里面的函数" class="headerlink" title="1.调用函数里面的函数"></a>1.调用函数里面的函数</h3><p>函数里面的函数能够保证外面的函数的作用域不会被销毁，所以无论是在函数里面还是在外面调用函数里面的函数都可以访问到外层函数的作用域，具体做法可以将里面函数当做返回值返回后通过两次的括号调用。</p>
<h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><p>回调函数会保留当前外层的作用域，然后回调到另一个地方执行，执行的时候就是闭包，nodejs中回调函数十分常见。</p>
<h3 id="3-IIFE方式"><a href="#3-IIFE方式" class="headerlink" title="3.IIFE方式"></a>3.IIFE方式</h3><p>(function(){})()这种格式，立即执行函数。可以将外部变量显式传入。</p>
<h3 id="4-循环"><a href="#4-循环" class="headerlink" title="4.循环"></a>4.循环</h3><p>由于JavaScript没有块级作用域，所以循环直接是循环外面的作用域，如果循环是写在全局中，则循环里面的闭包保留的就是全局作用域，全局作用域只有一个，所以如下代码的输出不会是想象中的1到10，而是10个10<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原因是上面说的，每次循环保存的都是唯一的全局作用域，作用域中的i的值是循环最后一次的i，也就是10。<br>如果想得到1到10，应该用闭包保存每一次循环的i<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(j);</div><div class="line">        &#125;, <span class="number">0</span> );</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>循环中的闭包的最常见用法之一就是在循环中的事件绑定，需要正确地获取到元素才能正确地绑定事件。不过大部分情况下这种都是用事件委托的~</p>
<p>当然，<code>es6</code>以后就有块级作用域一说了，事情可以变得不那么复杂，不过闭包还是终究有用武之地的。</p>
<h2 id="特别需要注意使用闭包时this对象的指向"><a href="#特别需要注意使用闭包时this对象的指向" class="headerlink" title="特别需要注意使用闭包时this对象的指向"></a>特别需要注意使用闭包时<code>this</code>对象的指向</h2><p><code>this</code>对象是在运行时基于函数的执行环境绑定的：在全局函数中，<code>this</code>等于<code>window</code>，而当函数被作为某个对象的方法调用时，<code>this</code>等于那个对象。不过，匿名函数的执行环境具有全局性，因此其<code>this</code>对象通常指向<code>window</code>。<a href="http://blog.csdn.net/huntererer/article/details/50101129" target="_blank" rel="external">更多关于this的知识看这个</a><br>看一下下面这个例子会打印出”window”还是”outer”吧<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"outer"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.f()();  <span class="comment">// ?</span></div></pre></td></tr></table></figure></p>
<p>在闭包中，内部函数不会到外部函数去搜索<code>this</code>，所以例子中打印的是”window”。但是，可以通过把外部作用域的<code>this</code>对象保存到一个变量里，闭包就可以访问了，例子如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"outer"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> self.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.f()();  <span class="comment">// "outer"</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章简单介绍闭包及在JavaScript语言中的应用&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>一个画曲线的canvas练习</title>
    <link href="http://hunnble.github.io/2016/08/03/%E4%B8%80%E4%B8%AA%E7%94%BB%E6%9B%B2%E7%BA%BF%E7%9A%84canvas%E7%BB%83%E4%B9%A0/"/>
    <id>http://hunnble.github.io/2016/08/03/一个画曲线的canvas练习/</id>
    <published>2016-08-03T15:51:58.000Z</published>
    <updated>2016-12-26T14:56:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在github上follow了好多很厉害的前端er，有一位有个好多star的repo里面就是各种canvas的小练习，canvas玩好了还是有好处的，毕竟前端要是每天光操作操作dom甚至切切页面是没什么长进的，甚至会被写CRUD的童鞋嘲讽。于是我今天又什么都没做，就写了一个画贝塞尔曲线的练习。<a id="more"></a><br>今天上午起来以后微信里有个大哥发朋友圈说替别人招前端，要先做个投名状，就是点几下就生成贝塞尔曲线的，当然要能拽着点到处动，类似于sketch软件里的那个小工具，我虽然不去应聘，但是还是写了。<br>写到这里我又很难过，因为我没有用过sketch，所以需求都是根据自己的感觉来的，也不知道要的交互效果和功能是不是这样。没有用过sketch的原因是没有macbook用，所以我要从现在开始攒钱买macbook，但是又没有钱赚，所以估计攒够的时候也就是以后工作以后了，只希望我现在的电脑能再给力点坚持两年，以及坏掉的linux系统我过段时间能修好或者重装好。<br>也许是因为今天看了张鑫旭的博客，中了毒，所以我的废话格外的多，还是要开始说这个练习了。</p>
<h3 id="贝塞尔曲线是什么"><a href="#贝塞尔曲线是什么" class="headerlink" title="贝塞尔曲线是什么"></a>贝塞尔曲线是什么</h3><p>有时候在写css3的transition之后在开发者工具中看transition-timing-function这个属性，也就是什么ease-in,ease-out等等的时候，会发现是有不同形状的曲线从(0,0)坐标到(1,1)坐标的，代表不同的运动缓急，这个曲线就是贝塞尔曲线。它的特点是用少数的点就能产生复杂的平滑曲线。<br><img src="http://htmljs.b0.upaiyun.com/uploads/1415845715278-bezier-quadratic-animation.gif" alt="一次贝塞尔曲线"><br>它在计算机图形学领域的应用更加广泛，按下不表，贝塞尔曲线的更多内容可以看<a href="http://www.html-js.com/article/1628" target="_blank" rel="external">这里</a></p>
<h3 id="canvas如何画贝塞尔曲线"><a href="#canvas如何画贝塞尔曲线" class="headerlink" title="canvas如何画贝塞尔曲线"></a>canvas如何画贝塞尔曲线</h3><p>我们知道，有n个控制点的贝塞尔曲线称为n次贝塞尔曲线，canvas中提供了<code>quadraticCurveTo</code>和<code>bezierCurveTo</code>函数来画一次和二次贝塞尔曲线。</p>
<pre><code>quadraticCurveTo(x1, y1, x2, y2)
</code></pre><p>起始点是当前context的所在点，(x1,y1)是控制点的坐标，(x2,y2)是终点的坐标。</p>
<pre><code>bezierCurveTo(x1,y1,x2,y2,x3,y3,x4,y4)
</code></pre><p>起始点是当前context的所在点，按顺序，三个坐标分别是两个控制点和终点的坐标。</p>
<h3 id="拖拽的实现"><a href="#拖拽的实现" class="headerlink" title="拖拽的实现"></a>拖拽的实现</h3><p>js中拖拽的最常见实现思路很清晰，mousedown时改变一个变量的状态，mousemove时看这个变量的状态表示正在拖拽的话就根据鼠标坐标改变被拖拽元素的位置，mouseup时把变量状态变成表示未拖拽即可。<br>具体到这个练习中，mousedown时先判断按下的点是否有曲线的点，canvas有<code>isPointInPath</code>方法，但是这个方法只能判断点，而我的曲线点是有半径的小圆。所以用我定义好的<code>isSameNode</code>函数用距离判断，在两个半径距离以内的都属于重合（两个圆外切的最小圆心距就是两个圆的半径之和，这里两个圆半径一样）。如果有曲线就记下它在所有曲线（数组存储）的索引<code>draggingNodeIndex</code>和当前位置<code>lastLoc</code>。<br>然后是mousemove，这个前面已经说了。<br>mouseup的时候<code>draggingNodeIndex</code>变回-1，也就是没有被拖拽的状态。不过还要再判断一下放下的这里有没有点已经在这儿了，如果有，被拖拽的点就回到<code>lastLoc</code>存储的旧位置中去。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个练习实现起来没什么难度，我是用requirejs来模块化的，感觉不错。<br><a href="http://hunnble.github.io/JavaScript_demo/bezier-drawer/index.html">demo地址，双击创建新点/画曲线/曲线消失</a><br><a href="https://github.com/hunnble/JavaScript_demo/tree/gh-pages/bezier-drawer" target="_blank" rel="external">源码地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在github上follow了好多很厉害的前端er，有一位有个好多star的repo里面就是各种canvas的小练习，canvas玩好了还是有好处的，毕竟前端要是每天光操作操作dom甚至切切页面是没什么长进的，甚至会被写CRUD的童鞋嘲讽。于是我今天又什么都没做，就写了一个画贝塞尔曲线的练习。
    
    </summary>
    
      <category term="frontend" scheme="http://hunnble.github.io/category/frontend/"/>
    
      <category term="demo" scheme="http://hunnble.github.io/category/frontend/demo/"/>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="canvas" scheme="http://hunnble.github.io/tag/canvas/"/>
    
  </entry>
  
  <entry>
    <title>React-redux实践</title>
    <link href="http://hunnble.github.io/2016/08/01/React-redux%E5%AE%9E%E8%B7%B5/"/>
    <id>http://hunnble.github.io/2016/08/01/React-redux实践/</id>
    <published>2016-08-01T09:16:56.000Z</published>
    <updated>2018-07-25T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>对于复杂的单页面应用，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。如果 state 变化不可预测，就会难于调试（state 不易重现，很难复现一些 bug）和不易于扩展（比如，优化更新渲染、服务端渲染、路由切换时获取数据等等）。<br>redux解决了state的问题，它的特点沿袭了flux，主要有：</p>
<ul>
<li>state 以单一对象存储在 store 对象中</li>
<li>state 只读</li>
<li>使用纯函数 reducer 执行 state 更新</li>
</ul>
<blockquote>
<p>state 为单一对象，使得 Redux 只需要维护一棵状态树，服务端很容易初始化状态，易于服务器渲染。state 只能通过 dispatch(action) 来触发更新，更新逻辑由 reducer 来执行。</p>
</blockquote>
<p><img src="http://staltz.com/img/redux-unidir-ui-arch.jpg" alt="redux"><br>图来自 <a href="http://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="external">UNIDIRECTIONAL USER INTERFACE ARCHITECTURES</a></p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action一般是向store传递用户的交互信息。dispatch一个action是一个同步的过程，更新 state -&gt; 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。</p>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>reducer 实际上就是一个函数：<code>(previousState, action) =&gt; newState</code>。用来执行根据指定 action 来更新 state 的逻辑。通过 <code>combineReducers(reducers)</code> 可以把多个 reducer 合并成一个 root reducer。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>state的主要特征：</p>
<ul>
<li>管理应用的 state</li>
<li>通过 <code>store.getState()</code> 可以获取 state</li>
<li>通过 <code>store.dispatch(action)</code> 来触发 state 更新</li>
<li>通过 <code>store.subscribe(listener)</code> 来注册 state 变化监听器</li>
<li>通过 <code>createStore(reducer, [initialState])</code> 创建<h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3>单页面应用中充斥着大量的异步请求（ajax）。dispatch(action) 是同步的，如果要处理异步 action，需要使用一些中间件。<br>中间件是某种实现特定功能的高阶函数，作用于 dispatch 返回一个新的 dispatch（附加了该中间件功能）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">thunkMiddleware</span>(<span class="params">&#123; dispatch, getState &#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt;</div><div class="line">        <span class="keyword">typeof</span> action === <span class="string">'function'</span> ? action(dispatch, getState) : next(action)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过 thunk-middleware 我们可以看出中间件的一般形式：中间件函数接受两个参数参数： dispatch 和 getState（也就是说中间件可以获取 state 以及 dispatch new action）。中间件一般返回 next(action)。store 的创建过程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> reducer = combineReducers(reducers)</div><div class="line"><span class="keyword">const</span> finalCreateStore = applyMiddleware(promiseMiddleware, warningMiddleware,</div><div class="line">    loggerMiddleWare)(createStore)</div><div class="line"><span class="keyword">const</span> store = finalCreateStore(reducer)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;对于复杂的单页面应用，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://hunnble.github.io/tag/React/"/>
    
  </entry>
  
  <entry>
    <title>Web Audio API</title>
    <link href="http://hunnble.github.io/2016/07/30/Web-Audio-API/"/>
    <id>http://hunnble.github.io/2016/07/30/Web-Audio-API/</id>
    <published>2016-07-30T13:11:23.000Z</published>
    <updated>2018-07-25T15:35:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天什么都没干，就看了一个Web Audio的API然后做了个音频可视化的小demo，呃呃，地址在这里。<br><del><a href="http://hunnble.github.io/JavaScript_demo/web-audio/index.html">demo地址(我把音乐删掉了所以demo看不了了)</a></del></p>
<a id="more"></a>
<p>我早就想玩音频可视化了但是以前用html5的audio标签就没有解析音频的接口。然后昨天才知道有Web Audio这个东西。然后我发现audio标签的功能是这个API的子集，这个API跟多媒体啊信号啊有关的实现的属性和方法很多。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API" target="_blank" rel="external">Web Audio MDN文档</a><br>属性和方法太多了，我今天只掌握了用到的几个，而它们都是基于AudioContext的:</p>
<blockquote>
<p>AudioContext接口代表由音频模块构成的音频处理图。音频环境控制其所包含节点的创建和音频处理、解码的执行。进行任何处理前你必需创建一个音频环境，一切操作都在这个环境里进行。</p>
</blockquote>
<p>这个是最主要的~~~<br>我的代码里用一个函数来封装get它，因为很多浏览器会不兼容这个API嘛:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAudioContext</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ac;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ac = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext || <span class="built_in">window</span>.mozAudioContext)();</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'不支持web audio api: '</span> + e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ac;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是AudioContext.createBufferSource方法</p>
<blockquote>
<p>返回AudioBufferSourceNode，它能让AudioContext.decodeAudioData方法解析它的音频数据从而播放。</p>
</blockquote>
<p>AudioContext.createGain方法</p>
<blockquote>
<p>返回GainNode, 起控制音量的作用</p>
</blockquote>
<p>AudioContext.createAnalyser</p>
<blockquote>
<p>AudioContext的createAnalyser()方法能创建一个AnalyserNode，可以用来获取音频时间和频率数据，以及实现数据可视化。</p>
</blockquote>
<p>AudioContext.destination属性</p>
<blockquote>
<p>返回AudioDestinationNode对象，表示当前audio context中所有节点的最终节点，一般表示音频渲染设备。</p>
</blockquote>
<p>简单了解了上面这几个属性和方法以后就可以做出音频可视化+控制音量的小demo了。初始化的方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this.ac = getAudioContext()</span></div><div class="line">Player.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.source = <span class="keyword">this</span>.ac.createBufferSource();</div><div class="line">    <span class="keyword">this</span>.gainNode = <span class="keyword">this</span>.ac.createGain ? <span class="keyword">this</span>.ac.createGain() : <span class="keyword">this</span>.ac.createGainNode();</div><div class="line">    <span class="keyword">this</span>.analyser = <span class="keyword">this</span>.ac.createAnalyser();</div><div class="line">    <span class="keyword">this</span>.gainNode.connect(<span class="keyword">this</span>.ac.destination);</div><div class="line">    <span class="keyword">this</span>.analyser.connect(<span class="keyword">this</span>.gainNode);</div><div class="line">    <span class="keyword">this</span>.source.connect(<span class="keyword">this</span>.analyser);</div><div class="line">    <span class="keyword">this</span>.gainNode.gain.value = <span class="number">0.5</span>;</div><div class="line">    <span class="keyword">this</span>.analyser.fftSize = <span class="keyword">this</span>.arrSize * <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为每个AudioBufferSource都只能start(noteOn)一次，所以每次切歌的时候这个方法都会重新调用生成新的。connect用来连接这些生成的实例。gainNode.gain.value就是音量了，取[0,1]区间的值。<br>整体的流程很简单，就是用XMLHTTPRequest来获取mp3，然后解析播放音频，并且解析出ArrayBuffer来用canvas生成可视化效果。直接放代码吧，写的有点乱，有时间慢慢填新效果吧，这只是个demo。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Player.prototype.playSound = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    self.xhr.abort();</div><div class="line">    self.xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">    self.xhr.responseType = <span class="string">'arraybuffer'</span>;</div><div class="line">    self.xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        self.ac.decodeAudioData(self.xhr.response, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</div><div class="line">            self.isPlaying &amp;&amp; self.stop();</div><div class="line">            self.init();</div><div class="line">            self.source.buffer = buffer;</div><div class="line">            self.source.start ? self.source.start(<span class="number">0</span>) : self.source.noteOn(<span class="number">0</span>);</div><div class="line">            self.visualize();</div><div class="line">            self.isPlaying = <span class="literal">true</span>;</div><div class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(err);</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line">    self.xhr.send();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Player.prototype.changeVolume = <span class="function"><span class="keyword">function</span> (<span class="params">percent</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.gainNode.gain.value = percent;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Player.prototype.stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.source.stop ? <span class="keyword">this</span>.source.stop() : <span class="keyword">this</span>.source.noteOff();</div><div class="line">    <span class="keyword">this</span>.isPlaying = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Player.prototype.visualize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(self.analyser.frequencyBinCount);</div><div class="line">    <span class="keyword">var</span> v = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        self.analyser.getByteFrequencyData(arr);</div><div class="line">        self.draw(arr);</div><div class="line">        self.isPlaying ? RAF(v) : cancelRAF(v);</div><div class="line">    &#125;;</div><div class="line">    RAF(v);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Player.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> perWidth = <span class="keyword">this</span>.canvas.width / <span class="keyword">this</span>.arrSize;</div><div class="line">    <span class="keyword">var</span> perHeight;</div><div class="line">    <span class="keyword">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.height);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.arrSize; ++i) &#123;</div><div class="line">        perHeight = arr[i] / <span class="keyword">this</span>.arrSize / <span class="number">2</span> * <span class="keyword">this</span>.canvas.height;</div><div class="line">        <span class="keyword">this</span>.ctx.fillRect(perWidth * i, <span class="keyword">this</span>.canvas.height - perHeight, perWidth, perHeight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RAF忘了说了，是动画的那个API,RequestAnimationFrame，配合canvas很好用。</p>
<p>嗯，这个API在MDN里也好多没有翻译的页，我在考虑要不要去帮忙翻译几个。<br>关于Audio的js库有个howler，看起来不错的，如果业务代码里要加音频什么的还是推荐用这种库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天什么都没干，就看了一个Web Audio的API然后做了个音频可视化的小demo，呃呃，地址在这里。&lt;br&gt;&lt;del&gt;&lt;a href=&quot;http://hunnble.github.io/JavaScript_demo/web-audio/index.html&quot;&gt;demo地址(我把音乐删掉了所以demo看不了了)&lt;/a&gt;&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>身份证号匹配正则</title>
    <link href="http://hunnble.github.io/2016/07/21/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%AD%A3%E5%88%99/"/>
    <id>http://hunnble.github.io/2016/07/21/身份证号匹配正则/</id>
    <published>2016-07-20T19:17:47.000Z</published>
    <updated>2018-07-25T15:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续编写我的正则库cr.js，长了不少知识，比如手机号的格式啊身份证号的格式啊什么的。身份证号我写的是二代身份证，也就是18位的那个。</p>
<a id="more"></a>
<p>18位的身份证分成三部分：</p>
<h4 id="1-地区码"><a href="#1-地区码" class="headerlink" title="1.地区码"></a>1.地区码</h4><p>前六位是地区码，跟注册身份证的地点（一般就是出生地）关联，正则表达式就很好写，是这个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\\d&#123;6&#125;'</span></div></pre></td></tr></table></figure></p>
<h4 id="2-出生日期"><a href="#2-出生日期" class="headerlink" title="2.出生日期"></a>2.出生日期</h4><p>中间8位是出生年月日，YYYYMMDD的格式。我本来不打算把日期匹配加到库里了因为用正则匹配这种纯数字的日期还不如用js的内建函数方便。不过既然现在需要用了，也不是不会，而且身份证的年份我只取了19和20开始的，也算降低难度了（也没怎么降啊其实，但是还是自我安慰一下啊哈哈哈）<br>由于2月份的特殊性，所以要判断闰年，判断闰年分能被4整除不能被100整除的情况和能被400整除的情况。<br>先从最普遍的情况开始：每个月都有1号到28号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'(?:(19[0-9]&#123;2&#125;|200[0-9]|201[0-6])(?:(?:(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8]))'</span></div></pre></td></tr></table></figure></p>
<p>你会看到我加了很多?:，这是用非捕获组来优化性能，我也是第一次这么用。<br>下面又是两种比较好写的情况：除二月之外的其它月份有29号和30号，13578十腊有31号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'(?:(?:0[13-9]|1[0-2])(?:29|30))|(?:0[13578]|1[02])31))'</span></div></pre></td></tr></table></figure></p>
<p>好了下面是BOSS关<br>我先把表达式写出来，我得看着写~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'(?:(?:(19|20)(?:0[48]|[2468][048]|[13579][26]))|2000)0229'</span></div></pre></td></tr></table></figure></p>
<p>啊，其实也不长哈，我怎么错了那么多次才写好…<br>只需要19和20开头的年份，<code>(0[48]|[2468][048]|[13579][26])</code>是能被4整除不能被100整除的后两位，而另一种情况是能被400整除的，如果是从公园0年开始计的话应该是<code>(0[48]|[2468][048]|[13579][26])00</code>这样的，后两位肯定是00，前两位能被4整除就可以。然而我只用(1900, 2016]这个区间，所以符合的只有2000这一个。<br>最后再放上<code>0229</code>。<br>最后的最后把这几个小串用<code>|</code>连接起来。</p>
<h4 id="3-最后4位"><a href="#3-最后4位" class="headerlink" title="3.最后4位"></a>3.最后4位</h4><p>光用地区和日期区分肯定会有很多同年同月同日同地区出生的人重合，所以后四位是区分码，其中第三位，也就是身份证的第十七位遵守男单数女双数的规则。最后一位也就是身份证的第十八位除了阿拉伯数字之外还可以出现大写英文字母X。<br>所以这么匹配就好了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'([0-9]&#123;3&#125;[0-9X])'</span></div></pre></td></tr></table></figure></p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>我上面写的都是字符串形式的，所以最后把字符串合并，然后用它创建新的RegExp实例就可以了。<br>详细代码点<a href="https://github.com/hunnble/common_regexps/blob/master/index.js" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续编写我的正则库cr.js，长了不少知识，比如手机号的格式啊身份证号的格式啊什么的。身份证号我写的是二代身份证，也就是18位的那个。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="regexp" scheme="http://hunnble.github.io/tag/regexp/"/>
    
  </entry>
  
  <entry>
    <title>几种跨域的方法</title>
    <link href="http://hunnble.github.io/2016/07/11/%E5%87%A0%E7%A7%8D%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://hunnble.github.io/2016/07/11/几种跨域的方法/</id>
    <published>2016-07-11T13:49:20.000Z</published>
    <updated>2018-07-25T15:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>谈到前端肯定少不了Ajax,谈到Ajax肯定少不了跨域。诗兴大发的我很想说一句，哦，跨域，你就像毒蛇一样，美丽而又危险。<br>今天写小玩具的时候又遇到跨域问题，索性先粗略总结一下跨域的一些方法。</p>
<a id="more"></a>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>我刚开始学Ajax的时候要写demo练习嘛，所以就用世界上最好的语言php在后端echo一些数据。比如这样的：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin:./js/create_data.js"</span>);</div><div class="line">$test_obj1 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">2</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试一, data类型为数组"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading1"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="keyword">Array</span>(<span class="string">"aaaaaaaaaaaaa"</span>, <span class="string">"bbbbbbbbbbbbbb"</span>, <span class="string">"ccccccccccc"</span>)</div><div class="line">);</div><div class="line">$test_obj2 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">4</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试二, data类型为键值对(对象)"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading2"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="keyword">array</span>(</div><div class="line">        <span class="string">"aaa"</span>=&gt; <span class="string">"aaaaaa"</span>,</div><div class="line">        <span class="string">"bbb"</span>=&gt; <span class="string">"bbbbbbbbb"</span></div><div class="line">    )</div><div class="line">);</div><div class="line">$test_obj3 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">5</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试三, data类型为字符串(暂时不进行trim和过滤特殊字符操作)"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading3"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="string">"cccccccc！！！"</span></div><div class="line">);</div><div class="line">$test_obj4 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">5</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试四, data类型为含有对象的数组"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading4"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="keyword">Array</span>(<span class="string">"data1"</span>, <span class="keyword">array</span>(<span class="string">"data2"</span>=&gt; <span class="string">"data2value"</span>), <span class="string">"data3"</span>)</div><div class="line">);</div><div class="line">$test_obj5 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">5</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试五 data类型为含有数组的对象"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading5"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="keyword">array</span>(</div><div class="line">        <span class="string">'data1'</span>=&gt; <span class="string">"data1value"</span>,</div><div class="line">        <span class="string">'data2'</span>=&gt; <span class="keyword">Array</span>(<span class="string">"data2"</span>, <span class="string">"data3"</span>)</div><div class="line">    )</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> json_encode(<span class="keyword">Array</span>($test_obj1, $test_obj2, $test_obj3, $test_obj4, $test_obj5));</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>第一次写的时候没有加第二行的那个添加http头的语句，在运行的时候就报错，因为我当时测试当然是在本地，本地不同文件夹不在同一域内，这就形成了跨域。<br>而聪明的我机智地找到了破解之法，那就是给php手动设置Access-Control-Allow-Origin，允许我前端的文件去访问，再次在前端get，成功得到数据。这种方法叫做CORS（跨域资源共享，Cross-Origin Resource Sharing），这种方法比较方便，浏览器的兼容性也不错，被广泛运用在移动端。<br>但是不能满足于此，比如今天我遇到的问题是要用豆瓣的读书API，总不能给豆瓣API小组打电话说：“嗨，给我加一行代码吧我跨域了解决不了了在线等挺急的。”吧。所以说打铁还需自身硬（这句话怎么怪怪的），一定有别的方法可以（在一定程度上）直接解决跨域问题。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP吧，这个方法很强大滴。<br>今天想玩玩豆瓣API，给自己正在用express做的一个书单（叫图书管理系统总是有种浓浓的大作业风）应用加点内容，然后去<a href="https://developers.douban.com/wiki/?title=book_v2" target="_blank" rel="external">豆瓣API文档</a>看了看就开始写了。为了简洁还是用上了jQuery，今天试的是根据图书名来获取图书信息。<br>路由：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">'/book/:name/:author'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  book.get(req.params.name, req.params.author, <span class="function"><span class="keyword">function</span> (<span class="params">err, _book</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!_book) &#123;</div><div class="line">      req.flash(<span class="string">'error'</span>, <span class="string">'获取书籍信息失败'</span>);</div><div class="line">      <span class="keyword">return</span> res.redirect(<span class="string">'/'</span>);</div><div class="line">    &#125;</div><div class="line">    res.render(<span class="string">'book'</span>, &#123;</div><div class="line">      <span class="attr">title</span>: _book.name,</div><div class="line">      <span class="attr">user</span>: req.session.user,</div><div class="line">      <span class="attr">success</span>: req.flash(<span class="string">'success'</span>).toString(),</div><div class="line">      <span class="attr">error</span>: req.flash(<span class="string">'error'</span>).toString()</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这段代码用不着读懂，因为有我自己在别处定义的方法，大概的功能就是先去数据库里找有没有添加过name是参数name的书，有的话就渲染ejs模版book.ejs。重点在下面。<br>不在后端调用API而放在前端用Ajax是因为Ajax是随时想再获取就可以立刻获取嘛比如到时候用户向下浏览到底的时候就可以动态再加载一些数据，写在后端就要refresh整个页面了相当，Ajax的优势就体现在这儿了。<br>前端的处理我使用了JSONP，先讲原理然后放上代码就不用解释了，哈哈。<br>JSONP是JSON with padding（填充式JSON）的简写，意思就是被包裹在函数中的json：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callback (&#123;<span class="string">'name'</span>: <span class="string">'Tyrion'</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的网名字一般在请求中指定。数据则是传入回调函数中的JSON。<br>JSONP的实现是动态添加一个script标签，它是可以跨域的，给它的src属性指定为要访问的url即可。<br>在jQuery中，使用JSONP十分方便，只需要在ajax方法中改动几处。接着上面的代码来看我的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 调用豆瓣搜索书API并解析获取的json数据，动态渲染页面。</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBook</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="built_in">window</span>.location.pathname.split(<span class="string">'/'</span>)[<span class="number">2</span>];</div><div class="line"></div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">'GET'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'https://api.douban.com/v2/book/search?q='</span> + name,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</div><div class="line">        <span class="attr">jsonp</span>: <span class="string">'callback'</span>,</div><div class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">            <span class="comment">// result就是豆瓣返回的json数据了。下面就可以使用数据来做事情...</span></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>name是从页面的url中取的name参数。<br>注意将数据类型指定为’jsonp’和指定jsonp: ‘callback’。</p>
<h3 id="img-Ping"><a href="#img-Ping" class="headerlink" title="img Ping"></a>img Ping</h3><p>这个没什么好说的啦，原理就是动态加一个img标签，跟JSONP一个道理。但是和script不同，img无法对响应文本进行处理，所以只能用于get。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Done</span></div><div class="line">&#125;;</div><div class="line">img.src = <span class="string">'http://www.targetUrl.com?name=Tyrion'</span>;</div></pre></td></tr></table></figure></p>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>名字起的不错哈哈哈，<del>反正自从我用过celery后其它的框架啊库啊还有技术名词我都觉得挺好的</del><br>Comet在这个语境下指的是服务器推送，是服务器段向客户端推送数据的技术。<br>有两种实现Comet的方式：长轮询和流，根据名字应该已经能知道它们的实现方式了。这个我还没有用过，就不不懂装懂了。</p>
<h3 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h3><p>这个技术似乎被评价得很高，它是一个新浏览器API，可以现在浏览器和服务器之间提供一个单独而持久的连接，是基于HTTP而升级成的网Web Socket协议的连接。所以服务器需要是支持这个协议的。<br>Web Sockets提供一套API来实现，过段时间我学完会回来填坑的。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>放假回来一周了，每天晚上一点多都要习惯性地看一下电脑的电量然后看到是百分之百就会愣一下。同时看几本书所以导致一周下来都没有看到一半以上的所以潜意识里有点消沉，但是又都想看，但愿下周能看完最薄的一本哈哈哈。<br>好久没写css了再写的时候用LESS玩玩吧，感觉文档也不多，也有用过scss所以应该会很容易上手吧哈哈哈，也不知道它的媒体查询那块简洁不简洁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谈到前端肯定少不了Ajax,谈到Ajax肯定少不了跨域。诗兴大发的我很想说一句，哦，跨域，你就像毒蛇一样，美丽而又危险。&lt;br&gt;今天写小玩具的时候又遇到跨域问题，索性先粗略总结一下跨域的一些方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES6-函数的扩展</title>
    <link href="http://hunnble.github.io/2016/07/05/ES6-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://hunnble.github.io/2016/07/05/ES6-函数的扩展/</id>
    <published>2016-07-05T02:41:30.000Z</published>
    <updated>2018-07-25T15:34:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>js中函数是“一等公民”，ES6标准对函数做了一些扩展使得熟悉其它语言的程序员可以更快地上手，而js程序员也会发现函数更强大也更便于编写了。</p>
<a id="more"></a>
<h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>很多语言都支持函数有默认值，比如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span> <span class="params">(x = <span class="number">10</span>)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>ES6也引入了函数默认参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x = <span class="number">50</span>, y</span>) </span>&#123;</div><div class="line">    <span class="comment">// x: 50, y: undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>给参数指定默认值后，该参数及之后的参数不会被函数的length计数（rest参数也不会计数）。且有默认值的参数都不是尾参数，无法跳过，在调用函数的时候只能写undefined跳过。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y = <span class="number">50</span>, z</span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">...args</span>) </span>&#123;&#125;</div><div class="line">foo.length <span class="comment">// 1 =&gt; 只有x被计入length</span></div><div class="line">bar.length <span class="comment">// 0</span></div></pre></td></tr></table></figure></p>
<p>而可以省略参数时，也可以将参数默认值设置成undefined。</p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点…，作用是将一个数组转为参数序列。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// 1 2 3</span></div></pre></td></tr></table></figure></p>
<p>扩展运算符的主要用途是解构rest参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</div><div class="line">    array.push(...items);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>函数的name属性返回该函数的函数名。<br>将具名函数赋值给一个变量，name属性返回具名函数的名字。<br>Function构造函数返回的函数实例，name属性的值为”anonymous”。<br>bind返回的函数name属性值会加上”bound “前缀。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> f4 = <span class="function"><span class="keyword">function</span> <span class="title">f3</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> f5 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f1.name, f2.name, f4.name, (<span class="keyword">new</span> <span class="built_in">Function</span>).name, f5.bind(&#123;&#125;).name); <span class="comment">// f1 f2 f3 anonymous bound f5</span></div></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6允许使用箭头定义函数，箭头长这样: =&gt;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> result;</div></pre></td></tr></table></figure></p>
<p>这种是最简单的形式，参数列表加返回值。<br>如果代码部分多于一条语句就要用大括号了，且要写return。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> arg1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于大括号被解释成代码块，所以返回的是对象的时候为了区分，要在对象外面加上括号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">a</span> =&gt;</span> (&#123;<span class="attr">r1</span>: a&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>箭头函数可以绑定this对象，淘汰了显式绑定this对象的写法，如call,apply,bind等。</li>
<li>函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象。原因是上一条的箭头函数自身没有this，所以this总是指定义时所在的对象。</li>
<li>不可以当作构造函数，即不可以使用new命令。原因也是自身没有this。</li>
<li>没有arguments对象了，喜闻乐见。</li>
<li>不可以使用yield命令，即不能作为Generator函数。</li>
</ul>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用是函数式编程的一个概念，就是指某个函数的最后一步是调用另一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> g(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数调用会在内部形成调用帧（call frame）用以保存调用位置和内部变量等信息，如果在函数A的内部调用函数B，那么B的调用帧会在A的调用帧上方。以此类推，调用帧会形成栈的数据结构，称为调用栈（call stack）。<br>由于尾调用是外部函数最后一次操作，所以可以如下优化：用内层函数的调用帧取代外层函数的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>  <span class="title">f</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> m = <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> n = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> g(m + n);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> g(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">g(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js中函数是“一等公民”，ES6标准对函数做了一些扩展使得熟悉其它语言的程序员可以更快地上手，而js程序员也会发现函数更强大也更便于编写了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6-数组的扩展</title>
    <link href="http://hunnble.github.io/2016/06/30/ES6-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://hunnble.github.io/2016/06/30/ES6-数组的扩展/</id>
    <published>2016-06-30T02:38:03.000Z</published>
    <updated>2018-07-25T15:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6对Array的扩展</p>
<a id="more"></a>
<h3 id="from方法"><a href="#from方法" class="headerlink" title="from方法"></a>from方法</h3><p>Array.from方法用于将类似数组的对象（array-like object）和可遍历对象（iterable）转化为真正的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arrayLike = &#123;</div><div class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="string">'o'</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="string">'e'</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> arrES5 = [].slice.call(arrayLike); <span class="comment">// ['a', 'o', 'e']</span></div><div class="line"><span class="keyword">let</span> arrES6 = arrayLike.from(arrayLike); <span class="comment">// ['a', 'o', 'e']</span></div><div class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.from(<span class="string">'aoe'</span>); <span class="comment">// ['a', 'o', 'e']</span></div></pre></td></tr></table></figure></p>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合以及函数内部的arguments对象，Array.form可以将它们转换成真正的数组。<br>Array.from的用处在于，将各种值转为数组后，可以有效使用各种数组方法来处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回参数类型组成的数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typesOf</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, value =&gt; <span class="keyword">typeof</span> value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一个应用是将字符串转为数组来求长度，绕过了Unicode的\uFFFF限制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span> (<span class="params">string</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="of方法"><a href="#of方法" class="headerlink" title="of方法"></a>of方法</h3><p>Array.of方法将一组值转换为数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// [2, 3, 4]</span></div></pre></td></tr></table></figure></p>
<h3 id="copyWithin方法"><a href="#copyWithin方法" class="headerlink" title="copyWithin方法"></a>copyWithin方法</h3><p>Array.prototype.copyWithin将当前数组内部指定位置的成员复制到其它位置（会覆盖原有成员），然后返回当前数组。它接受三个参数：target, start = 0, end = this.length</p>
<ul>
<li>target（必需）： 从这个位置开始替换数据。</li>
<li>start：从这个位置开始读取数据，负值表示倒数</li>
<li>end：到这个位置停止读取数据。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-3</span>) <span class="comment">// [4,5,3,4,5]</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-3</span>) <span class="comment">// [3,4,5,4,5]</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [4,2,3,4,5]</span></div></pre></td></tr></table></figure>
<h3 id="find-findIndex方法"><a href="#find-findIndex方法" class="headerlink" title="find,findIndex方法"></a>find,findIndex方法</h3><p>find方法用于找出数组中第一个符合条件的数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].find(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value &gt; <span class="number">3</span>;</div><div class="line">&#125;) <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>findIndex则是返回索引值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value &gt; <span class="number">3</span>;</div><div class="line">&#125;) <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h3 id="fill方法"><a href="#fill方法" class="headerlink" title="fill方法"></a>fill方法</h3><p>fill方法使用给定值填充数组，第二个参数指定填充的起始位置，第三个参数指定填充的结束位置。</p>
<h3 id="entries-keys-values方法"><a href="#entries-keys-values方法" class="headerlink" title="entries,keys,values方法"></a>entries,keys,values方法</h3><p>这三个方法都用于遍历数组，返回值都是遍历器对象，区别是：entries是对键值对的遍历，keys是对键名的遍历，而values是对键值的遍历。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'o'</span>, <span class="string">'e'</span>].entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(index + <span class="string">':'</span> + elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0:a</span></div><div class="line"><span class="comment">// 1:o</span></div><div class="line"><span class="comment">// 2:e</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'o'</span>, <span class="string">'e'</span>].keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'o'</span>, <span class="string">'e'</span>].values()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'o'</span></div><div class="line"><span class="comment">// 'e'</span></div></pre></td></tr></table></figure></p>
<h3 id="includes方法"><a href="#includes方法" class="headerlink" title="includes方法"></a>includes方法</h3><p>Array.prototype.includes方法返回一个布尔值，表示数组是否包含给定值。第二个参数表示搜索的起始位置。</p>
<h3 id="对数组空位的处理"><a href="#对数组空位的处理" class="headerlink" title="对数组空位的处理"></a>对数组空位的处理</h3><p>书上说，数组各方法对数组空位的处理是有区别的，不过大部分都是忽略二字。</p>
<ul>
<li>forEach(),filter(),every()和some():跳过空位</li>
<li>map():跳过，但是保留值</li>
<li>join()和toString():将空位当做undefined处理</li>
<li>from():将空位转为undefined</li>
<li>copyWithin():不忽略空位，也会一视同仁地复制</li>
<li>fill():不跳过空位，空位也会被填充</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6对Array的扩展&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hunnble.github.io/tag/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
