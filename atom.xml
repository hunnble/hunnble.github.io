<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>北方公园</title>
  <subtitle>Web/书和思考/一派胡言</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hunnble.github.io/"/>
  <updated>2016-12-08T15:14:18.000Z</updated>
  <id>http://hunnble.github.io/</id>
  
  <author>
    <name>Noski</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AppleScript实现hexo新建/发布工作流</title>
    <link href="http://hunnble.github.io/2016/12/08/AppleScript%E5%AE%9E%E7%8E%B0hexo%E6%96%B0%E5%BB%BA-%E5%8F%91%E5%B8%83%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://hunnble.github.io/2016/12/08/AppleScript实现hexo新建-发布工作流/</id>
    <published>2016-12-08T14:50:03.000Z</published>
    <updated>2016-12-08T15:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在折腾hexo主题，然后发现在OSX系统中可以用AppleScript脚本实现很多快捷的工作流小应用。所以花了半个下午在别人的基础上改写了两个AppleScript脚本实现hexo的快速部署。<br><a id="more"></a></p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在没有脚本的情况下，用hexo新建一篇文章的流程是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">hexo new &quot;文章名&quot;</div><div class="line">...切换到命令行</div><div class="line">...切换到编辑器写文章</div><div class="line">...切换到命令行</div><div class="line">hexo clean</div><div class="line">hexo g</div><div class="line">gulp</div><div class="line">hexo d</div></pre></td></tr></table></figure></p>
<p>因为我用gulp压缩要发布的html,css,js,image所以不能直接<code>hexo d -g</code>这样。<br>这样太麻烦了，为了节省自己的时间，我如上文所说的那样花了半个下午去了解了一下AppleScript并且写了两个脚本。呃呃，不知道要写多少篇文章才能把半个下午节约回来…哈哈</p>
<h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo-new"></a>hexo-new</h3><p>下面是新建hexo的脚本，执行效果是弹出dialog，填写文章名后确认，自动打开Atom编辑器编辑文章。<br><figure class="highlight applescript"><figcaption><span>hexo-new</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Finder"</span></div><div class="line">	<span class="built_in">activate</span></div><div class="line">	<span class="built_in">display dialog</span> <span class="string">"填入文章标题"</span> default answer <span class="string">"title"</span></div><div class="line">	<span class="keyword">set</span> title <span class="keyword">to</span> <span class="built_in">text</span> returned <span class="keyword">of</span> <span class="literal">result</span> <span class="keyword">as</span> <span class="built_in">text</span></div><div class="line"><span class="keyword">end</span> <span class="keyword">tell</span></div><div class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Terminal"</span></div><div class="line">	<span class="built_in">activate</span></div><div class="line">	<span class="keyword">if</span> (<span class="built_in">count</span> <span class="keyword">of</span> windows) <span class="keyword">is</span> <span class="number">0</span> <span class="keyword">then</span></div><div class="line">		<span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"System Events"</span></div><div class="line">			keystroke <span class="string">"n"</span> using &#123;command down&#125;</div><div class="line">		<span class="keyword">end</span> <span class="keyword">tell</span></div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">activate</span></div><div class="line">	<span class="keyword">end</span> <span class="keyword">if</span></div><div class="line">	<span class="keyword">set</span> win <span class="keyword">to</span> window [<span class="number">0</span>]</div><div class="line">	<span class="keyword">set</span> currentTab <span class="keyword">to</span> selected <span class="literal">tab</span> <span class="keyword">of</span> win</div><div class="line">	do <span class="keyword">script</span> <span class="string">"cd ........../hexo_blog"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"hexo new "</span> &amp; title <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">1</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"open -a Atom source/_posts/"</span> &amp; title &amp; <span class="string">".md"</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">3</span></div><div class="line">	close windows</div><div class="line"><span class="keyword">end</span> <span class="keyword">tell</span></div></pre></td></tr></table></figure></p>
<h3 id="hexo-publish"><a href="#hexo-publish" class="headerlink" title="hexo-publish"></a>hexo-publish</h3><p>第二个是发布的脚本，执行效果是直接发布，什么都不用做，之后会自行关闭终端。<br><figure class="highlight applescript"><figcaption><span>hexo-publish</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Terminal"</span></div><div class="line">	<span class="built_in">activate</span></div><div class="line">	<span class="keyword">set</span> win <span class="keyword">to</span> window [<span class="number">0</span>]</div><div class="line">	<span class="keyword">set</span> currentTab <span class="keyword">to</span> selected <span class="literal">tab</span> <span class="keyword">of</span> win</div><div class="line">	do <span class="keyword">script</span> <span class="string">"cd ........../hexo_blog"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"hexo clean "</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">1</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"hexo g "</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="comment">-- 生成CNAME，供域名解析</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"cd public"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"touch CNAME"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"echo www.yoursite.com &gt; CNAME"</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">5</span></div><div class="line">	<span class="comment">-- 压缩</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"cd ../"</span> <span class="keyword">in</span> currentTab</div><div class="line">	do <span class="keyword">script</span> <span class="string">"gulp"</span> <span class="keyword">in</span> currentTab</div><div class="line">	<span class="built_in">delay</span> <span class="number">10</span></div><div class="line">	do <span class="keyword">script</span> <span class="string">"hexo d"</span> <span class="keyword">in</span> currentTab</div><div class="line">	close windows</div><div class="line"><span class="keyword">end</span> <span class="keyword">tell</span></div></pre></td></tr></table></figure></p>
<p>根据自己的需求加上gulp的调用和CNAME文件的写入。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>脚本写完之后保存的默认格式是scpt，另存为app就可以用Alfred或者spotlight或者放Dock或者别的地方打开来完成hexo写博客并发布的工作流了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在折腾hexo主题，然后发现在OSX系统中可以用AppleScript脚本实现很多快捷的工作流小应用。所以花了半个下午在别人的基础上改写了两个AppleScript脚本实现hexo的快速部署。&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://hunnble.github.io/tag/hexo/"/>
    
  </entry>
  
  <entry>
    <title>用js实现几种排序算法</title>
    <link href="http://hunnble.github.io/2016/11/05/%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://hunnble.github.io/2016/11/05/用js实现几种排序算法/</id>
    <published>2016-11-05T01:49:07.000Z</published>
    <updated>2016-11-05T07:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天周六，打算花一些时间把几种排序算法使用js实现一下。<br><a id="more"></a></p>
<h3 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h3><p>首先用mocha+chai写几行测试，然后测排序是不是正确就不用自己瞅了…以测试归并排序为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</div><div class="line"><span class="keyword">var</span> sortFuncs = <span class="built_in">require</span>(<span class="string">'./sort.js'</span>);</div><div class="line"></div><div class="line">describe(<span class="string">'sort function must be right'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    describe(<span class="string">'merge sort'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> arr = arrayGenerator(<span class="number">20</span>);</div><div class="line">        it(<span class="string">'merge sort should be correct'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            expect(sortFuncs.mergeSort(arr)).to.eql(sort(arr));</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayGenerator</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        arr.push(<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">100</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">v1, v2</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> v2 - v1;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成随机数组成的数组，然后去断言被测试的函数的排序结果是否和js的sort返回的正确结果一致。我今天写的所有排序都是从大到小哈。</p>
<h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h3><p>直接上代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">a1, a2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">var</span> a1Cursor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> a2Cursor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (a1Cursor &lt; a1.length &amp;&amp; a2Cursor &lt; a2.length) &#123;</div><div class="line">        <span class="keyword">if</span> (a1[a1Cursor] &gt; a2[a2Cursor]) &#123;</div><div class="line">            result.push(a1[a1Cursor]);</div><div class="line">            a1Cursor += <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(a2[a2Cursor]);</div><div class="line">            a2Cursor += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result.concat(a1.slice(a1Cursor)).concat(a2.slice(a2Cursor));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span> || arr.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> n = <span class="built_in">parseInt</span>(arr.length / <span class="number">2</span>, <span class="number">10</span>);</div><div class="line">    <span class="keyword">var</span> a1 = arr.slice(<span class="number">0</span>, n);</div><div class="line">    <span class="keyword">var</span> a2 = arr.slice(n);</div><div class="line">    <span class="keyword">return</span> merge(mergeSort(a1), mergeSort(a2));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个是用递归实现了的，虽然实现了但是需要花很多额外的空间。<br>小小优化一下，在合并函数中不额外创建新数组result，而是把a2合并到a1上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">a1, a2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a1Cursor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> a2Cursor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (a1Cursor &lt; a1.length &amp;&amp; a2Cursor &lt; a2.length) &#123;</div><div class="line">        <span class="keyword">if</span> (a1[a1Cursor] &lt; a2[a2Cursor]) &#123;</div><div class="line">            a1.splice(a1Cursor, <span class="number">0</span>, a2[a2Cursor]);</div><div class="line">            a2Cursor += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        a1Cursor += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> a1.concat(a2.slice(a2Cursor));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯…好一点了。<br>实现了自顶向下的归并，下面来实现自底向上的非递归版本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">arr</span>) </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span> || arr.length === <span class="number">1</span>) &#123;  </div><div class="line">        <span class="keyword">return</span> arr;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">var</span> work = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;  </div><div class="line">        work.push([arr[i]]);  </div><div class="line">    &#125;  </div><div class="line">    work.push([]);  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> lim = len; lim &gt; <span class="number">1</span>; lim = (lim + <span class="number">1</span>) / <span class="number">2</span>) &#123;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; lim; j += <span class="number">1</span>, k += <span class="number">2</span>)&#123;  </div><div class="line">            work[j] = merge(work[k], work[k+<span class="number">1</span>]);  </div><div class="line">        &#125;  </div><div class="line">        work[j] = [];  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> work[<span class="number">0</span>];  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>思路很清晰，就是维护一个work数组，暂存分治的数组，自底向上合并。</p>
<h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h3><p>冒泡排序是把最大/小的元素冒泡到最后，快速排序是把比基准值(pivot)小的放一边，大的放一边，然后再分别排序。<br>上代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span> || arr.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> left = [];</div><div class="line">    <span class="keyword">var</span> right = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = arr.length; i &lt; len; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">0</span>]) &#123;</div><div class="line">            left.push(arr[i]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            right.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> quickSort(left).concat(arr[<span class="number">0</span>]).concat(quickSort(right));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h3><p>希尔排序就是给直接插入排序升级成隔很远的能更快比较的版本。间隔(gap)为1时就是直接插入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> gaps = [<span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>]; <span class="comment">// 间隔序列取10, 4, 1</span></div><div class="line">    <span class="keyword">var</span> arrLen = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, gapsLen = gaps.length; i &lt; gapsLen; ++i) &#123;</div><div class="line">        <span class="keyword">var</span> gap = gaps[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = gap; j &lt; arrLen; ++j) &#123;</div><div class="line">            <span class="keyword">var</span> tmp = arr[j];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> k = j; k &gt; gaps[i] &amp;&amp; arr[k - gap] &lt; tmp; k -= gap) &#123;</div><div class="line">                arr[k] = arr[k - gap];</div><div class="line">            &#125;</div><div class="line">            arr[k] = tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先这样，有空再更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天周六，打算花一些时间把几种排序算法使用js实现一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="algorithm" scheme="http://hunnble.github.io/tag/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>AMD模块加载工具requirejs</title>
    <link href="http://hunnble.github.io/2016/11/02/AMD%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%B7%A5%E5%85%B7requirejs/"/>
    <id>http://hunnble.github.io/2016/11/02/AMD模块加载工具requirejs/</id>
    <published>2016-11-02T12:58:44.000Z</published>
    <updated>2016-11-30T09:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>苏子曰：<br>“客亦知夫水与月乎?逝者如斯,而未尝往也；<br>盈虚者如彼,而卒莫消长也。<br>盖将自其变者而观之,而天地曾不能一瞬；<br>自其不变者而观之,则物于我皆无尽也。<br>而又何羡乎?<br>且夫天地之间,物各有主。<br>苟非吾之所有,虽一毫而莫取。<br>惟江上之清风,与山间之明月,耳得之而为声,目遇之而成色。<br>取之无禁,用之不竭。<br>是造物者之无尽藏也,而吾与子之所共适.”<br><a id="more"></a></p>
</blockquote>
<p>虽然2016年大家都在用<code>webpack</code>、<code>react</code>、<code>vue</code>和<code>ng2</code>什么的，但是我还是炒一下<code>jquery</code>和<code>requirejs</code>的冷饭吧。这篇博客就说一下这个AMD模块加载方案工具<code>requirejs</code>。</p>
<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>和<a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="external">CMD</a>的介绍就不放这里了。CMD的加载方案有<code>sea.js</code>，是阿里做的一套方案，我没有用过，因为<code>requirejs</code>已经够用了，更何况学<code>ES6</code>和<code>react</code>之后其实还是用<code>webpack</code>比较多。话说前端的轮子实在多的不行，写这篇博客之前一搜模块加载方案搜出来好几页。还好加载机制只有AMD/CMD/UMD/CommonJS，了解这几种思想就不用怕了，万变不离其宗嘛。</p>
<p><code>requirejs</code>的功能是js脚本的模块化，一句话解释一下，就是用模块名称代替url来加载js脚本。使用<code>requirejs</code>后就可以把一堆<code>script</code>标签用一行代替：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">"入口模块"</span> <span class="attr">src</span>=<span class="string">"require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>而入口模块，比如是js/index.js，那么在index.js中就要对<code>requirejs</code>进行配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">requirejs.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>: <span class="string">'默认路径'</span>,</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="string">'jquery'</span>: <span class="string">'jquery.min.js'</span>,</div><div class="line">        ...</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">&#125;);</div><div class="line"></div><div class="line">requirejs([<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">start</span>) </span>&#123;</div><div class="line">    start();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里用<code>jquery</code>举例子，其实只要是js脚本就可以当做模块加载进来的。config里的配置选项还有很多。</p>
<p>那么只要在被加载的js文件中定义好模块就可以使用了，比如a.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        $(<span class="built_in">document</span>).ready(run());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 可以用$了，哈哈</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最简单地加载模块方式就是这样，代码不会比不使用<code>requirejs</code>多很多，看着也清楚多了（废话，模块化了总不会更乱吧）。<br><code>requirejs</code>是异步加载模块，这比较符合广大js程序员的思维方式，而且模块之间有依赖关系也可以显式地在define时的数组参数中写出，不会因为异步加载导致加载失败。而且文档也挺全的。我今天写一个只用<code>jquery</code>的东西，用<code>webpack</code>感觉很大材小用了，要是不想每次编译还要开个服务器做hot-reloader，所以就又用了一次<code>requirejs</code>，还是挺好用的，哈哈。<br>最后还是说一句，其实还是ES6的<code>import</code>/<code>export</code>用的最爽。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;苏子曰：&lt;br&gt;“客亦知夫水与月乎?逝者如斯,而未尝往也；&lt;br&gt;盈虚者如彼,而卒莫消长也。&lt;br&gt;盖将自其变者而观之,而天地曾不能一瞬；&lt;br&gt;自其不变者而观之,则物于我皆无尽也。&lt;br&gt;而又何羡乎?&lt;br&gt;且夫天地之间,物各有主。&lt;br&gt;苟非吾之所有,虽一毫而莫取。&lt;br&gt;惟江上之清风,与山间之明月,耳得之而为声,目遇之而成色。&lt;br&gt;取之无禁,用之不竭。&lt;br&gt;是造物者之无尽藏也,而吾与子之所共适.”&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
  </entry>
  
  <entry>
    <title>好久没更新博客了</title>
    <link href="http://hunnble.github.io/2016/09/21/%E5%A5%BD%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E4%BA%86/"/>
    <id>http://hunnble.github.io/2016/09/21/好久没更新博客了/</id>
    <published>2016-09-20T16:04:02.000Z</published>
    <updated>2016-12-08T01:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更新博客了，即便是买了域名以后都一直没来写。主要的原因是买了新电脑，原来配置好hexo的这个电脑平常不怎么用了。倒是搜到有很多方便的多个电脑一起写hexo博客的方法，但是不想折腾了。而且最近一直在深入理解redux还有学koa，然后就是写那个名字还没起好的做问卷的系统。说真的，可能是我比较笨，所以花几乎一个月才掌握了koa再加熟练地把redux初步理解并且结合react写出来。<br>还是挺慢的，不过还好收获也蛮大的。<br><a id="more"></a><br>本来的计划是一个月左右写完，十一假期的时候部署起来。但是今天发现估计要延期好久，甚至koa2出beta版本以后这个应用能不能上线还不一定。koa1转koa2啊immutable.js啊什么的各种玩意儿也想都别想了。<br>收获还是蛮大的，之前那个聊天室应用我就发现我的js水平&gt;css水平&gt;审美水平了，这才第一次有了整自己的ui库/读bootstrap的scss版本源码的念头，但是这个项目用上material ui以后发现自己确实审美没天分，哈哈。而且我以前还没玩过svg，这就又是好几个事儿。偏偏我们这学校的课都是瞎安排，有用的课还没有水课多，比如周五一整天的工程实践这种简直反人类。而且我最近还发烧了，每天十二点多就要睡觉不然会很难受，还好每天起的还算早，基本上一天能有写一个组件的速率。<br>反正就是太慢了，没时间，十一之前但愿能做完基本功能吧, 前天又听说react-router又要发新版本大改api了，简直就是在鞭策我。<br>然后明天还要做出来课程设计的项目的文档，这个倒是挺exciting的，玩玩软件工程的东西，玩玩网络，要是买不起云服务器就还准备用electron写客户端，哈哈哈。<br>不过最近做这些东西都是乐趣远大于压力，所以最近还是很开心的哈哈哈。要学的东西还是太多太多了，怎么说呢，庶竭驽钝吧。<br>对了还有，经过ccf认证考试之后我发现我算法方面还是短板(虽然不知道我第一题是怎么0分的，但是最短路径那个题没写出代码真是自己水平太低的问题)，虽然假期很安逸地用js啊python啊写了60道不到的leetcode吧，但是还是太少了。希望我能在这学期结束前把免费题hard以下基本做完。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没更新博客了，即便是买了域名以后都一直没来写。主要的原因是买了新电脑，原来配置好hexo的这个电脑平常不怎么用了。倒是搜到有很多方便的多个电脑一起写hexo博客的方法，但是不想折腾了。而且最近一直在深入理解redux还有学koa，然后就是写那个名字还没起好的做问卷的系统。说真的，可能是我比较笨，所以花几乎一个月才掌握了koa再加熟练地把redux初步理解并且结合react写出来。&lt;br&gt;还是挺慢的，不过还好收获也蛮大的。&lt;br&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://hunnble.github.io/tag/life/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://hunnble.github.io/2016/08/17/%E9%97%AD%E5%8C%85/"/>
    <id>http://hunnble.github.io/2016/08/17/闭包/</id>
    <published>2016-08-17T03:52:05.000Z</published>
    <updated>2016-09-20T16:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章简单介绍闭包及在JavaScript语言中的应用<br><a id="more"></a></p>
<h2 id="离散数学中的闭包："><a href="#离散数学中的闭包：" class="headerlink" title="离散数学中的闭包："></a>离散数学中的闭包：</h2><p>包含指定集合的满足在某个运算下闭合的最小集合／如果集合A在某种操作作用下的结果仍然属于集合A，那么就认为集合A在这个操作下拥有闭包属性。也可以说，集合A在这个操作下是闭合的</p>
<h2 id="程序语言中的闭包："><a href="#程序语言中的闭包：" class="headerlink" title="程序语言中的闭包："></a>程序语言中的闭包：</h2><p>又叫词法闭包，或者函数闭包，指的是程序语言中的特性，具备该特性的程序语言能将函数和函数所处的环境当做整体使用。有时也把这个整体叫做闭包。</p>
<p><em>二者是不同的，这里说的是程序语言中的JavaScript中的闭包。JavaScript中的闭包指持有外部环境变量的函数。</em></p>
<h2 id="JavaScript中的闭包"><a href="#JavaScript中的闭包" class="headerlink" title="JavaScript中的闭包"></a>JavaScript中的闭包</h2><p>JavaScript闭包的本质源自两点，词法作用域和函数当作值传递。</p>
<h3 id="1-词法作用域"><a href="#1-词法作用域" class="headerlink" title="1.词法作用域"></a>1.词法作用域</h3><p>JavaScript的作用域链是指每一个函数内部不止可以访问它自己作用域中的变量，还可以访问包含它的函数作用域中的变量，一直上溯到全局变量，是为作用域链。</p>
<h3 id="2-函数当作值传递"><a href="#2-函数当作值传递" class="headerlink" title="2.函数当作值传递"></a>2.函数当作值传递</h3><p>JavaScript中函数是first-class的，可以被当做值来传递，一个函数可以return一个函数。</p>
<p><em>以上两点组成了形成闭包的条件，一言以蔽之，就是封闭外部作用域中一部分自由变量以及内部作用域，让内部作用域“记忆”外部状态。</em></p>
<p>看一个最简单的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">functionAdd(y)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> x + y</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对内部函数function(x)来讲，y就是自由变量，而且function(x)的返回值，依赖于这个外部自由变量y。而往上推一层，外围Add(y)函数正好就是那个包含自由变量y的环境。而且Javascript的语法允许内部函数function(x)访问外部函数Add(y)的局部变量。满足这三个条件，所以这个时候，外部函数Add(y)对内部函数function(x)构成了闭包。</p>
<h2 id="常见例子："><a href="#常见例子：" class="headerlink" title="常见例子："></a>常见例子：</h2><h3 id="1-调用函数里面的函数"><a href="#1-调用函数里面的函数" class="headerlink" title="1.调用函数里面的函数"></a>1.调用函数里面的函数</h3><p>函数里面的函数能够保证外面的函数的作用域不会被销毁，所以无论是在函数里面还是在外面调用函数里面的函数都可以访问到外层函数的作用域，具体做法可以将里面函数当做返回值返回后通过两次的括号调用。</p>
<h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><p>回调函数会保留当前外层的作用域，然后回调到另一个地方执行，执行的时候就是闭包，nodejs中回调函数十分常见。</p>
<h3 id="3-IIFE方式"><a href="#3-IIFE方式" class="headerlink" title="3.IIFE方式"></a>3.IIFE方式</h3><p>(function(){})()这种格式，立即执行函数。可以将外部变量显式传入。</p>
<h3 id="4-循环"><a href="#4-循环" class="headerlink" title="4.循环"></a>4.循环</h3><p>由于JavaScript没有块级作用域，所以循环直接是循环外面的作用域，如果循环是写在全局中，则循环里面的闭包保留的就是全局作用域，全局作用域只有一个，所以如下代码的输出不会是想象中的1到10，而是10个10<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原因是上面说的，每次循环保存的都是唯一的全局作用域，作用域中的i的值是循环最后一次的i，也就是10。<br>如果想得到1到10，应该用闭包保存每一次循环的i<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(j);</div><div class="line">        &#125;, <span class="number">0</span> );</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>循环中的闭包的最常见用法之一就是在循环中的事件绑定，需要正确地获取到元素才能正确地绑定事件。不过大部分情况下这种都是用事件委托的~</p>
<p>当然，<code>es6</code>以后就有块级作用域一说了，事情可以变得不那么复杂，不过闭包还是终究有用武之地的。</p>
<h2 id="特别需要注意使用闭包时this对象的指向"><a href="#特别需要注意使用闭包时this对象的指向" class="headerlink" title="特别需要注意使用闭包时this对象的指向"></a>特别需要注意使用闭包时<code>this</code>对象的指向</h2><p><code>this</code>对象是在运行时基于函数的执行环境绑定的：在全局函数中，<code>this</code>等于<code>window</code>，而当函数被作为某个对象的方法调用时，<code>this</code>等于那个对象。不过，匿名函数的执行环境具有全局性，因此其<code>this</code>对象通常指向<code>window</code>。<a href="http://blog.csdn.net/huntererer/article/details/50101129" target="_blank" rel="external">更多关于this的知识看这个</a><br>看一下下面这个例子会打印出”window”还是”outer”吧<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"outer"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.f()();  <span class="comment">// ?</span></div></pre></td></tr></table></figure></p>
<p>在闭包中，内部函数不会到外部函数去搜索<code>this</code>，所以例子中打印的是”window”。但是，可以通过把外部作用域的<code>this</code>对象保存到一个变量里，闭包就可以访问了，例子如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"outer"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> self.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.f()();  <span class="comment">// "outer"</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章简单介绍闭包及在JavaScript语言中的应用&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
  </entry>
  
  <entry>
    <title>一个画曲线的canvas练习</title>
    <link href="http://hunnble.github.io/2016/08/03/%E4%B8%80%E4%B8%AA%E7%94%BB%E6%9B%B2%E7%BA%BF%E7%9A%84canvas%E7%BB%83%E4%B9%A0/"/>
    <id>http://hunnble.github.io/2016/08/03/一个画曲线的canvas练习/</id>
    <published>2016-08-03T15:51:58.000Z</published>
    <updated>2016-11-30T16:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在github上follow了好多很厉害的前端er，有一位有个好多star的repo里面就是各种canvas的小练习，canvas玩好了还是有好处的，毕竟前端要是每天光操作操作dom甚至切切页面是没什么长进的，甚至会被写CRUD的童鞋嘲讽。于是我今天又什么都没做，就写了一个画贝塞尔曲线的练习。<a id="more"></a><br>今天上午起来以后微信里有个大哥发朋友圈说替别人招前端，要先做个投名状，就是点几下就生成贝塞尔曲线的，当然要能拽着点到处动，类似于sketch软件里的那个小工具，我虽然不去应聘，但是还是写了。<br>写到这里我又很难过，因为我没有用过sketch，所以需求都是根据自己的感觉来的，也不知道要的交互效果和功能是不是这样。没有用过sketch的原因是没有macbook用，所以我要从现在开始攒钱买macbook，但是又没有钱赚，所以估计攒够的时候也就是以后工作以后了，只希望我现在的电脑能再给力点坚持两年，以及坏掉的linux系统我过段时间能修好或者重装好。<br>也许是因为今天看了张鑫旭的博客，中了毒，所以我的废话格外的多，还是要开始说这个练习了。</p>
<h3 id="贝塞尔曲线是什么"><a href="#贝塞尔曲线是什么" class="headerlink" title="贝塞尔曲线是什么"></a>贝塞尔曲线是什么</h3><p>有时候在写css3的transition之后在开发者工具中看transition-timing-function这个属性，也就是什么ease-in,ease-out等等的时候，会发现是有不同形状的曲线从(0,0)坐标到(1,1)坐标的，代表不同的运动缓急，这个曲线就是贝塞尔曲线。它的特点是用少数的点就能产生复杂的平滑曲线。<br><img src="http://htmljs.b0.upaiyun.com/uploads/1415845715278-bezier-quadratic-animation.gif" alt="一次贝塞尔曲线"><br>它在计算机图形学领域的应用更加广泛，按下不表，贝塞尔曲线的更多内容可以看<a href="http://www.html-js.com/article/1628" target="_blank" rel="external">这里</a></p>
<h3 id="canvas如何画贝塞尔曲线"><a href="#canvas如何画贝塞尔曲线" class="headerlink" title="canvas如何画贝塞尔曲线"></a>canvas如何画贝塞尔曲线</h3><p>我们知道，有n个控制点的贝塞尔曲线称为n次贝塞尔曲线，canvas中提供了<code>quadraticCurveTo</code>和<code>bezierCurveTo</code>函数来画一次和二次贝塞尔曲线。</p>
<pre><code>quadraticCurveTo(x1, y1, x2, y2)
</code></pre><p>起始点是当前context的所在点，(x1,y1)是控制点的坐标，(x2,y2)是终点的坐标。</p>
<pre><code>bezierCurveTo(x1,y1,x2,y2,x3,y3,x4,y4)
</code></pre><p>起始点是当前context的所在点，按顺序，三个坐标分别是两个控制点和终点的坐标。</p>
<h3 id="拖拽的实现"><a href="#拖拽的实现" class="headerlink" title="拖拽的实现"></a>拖拽的实现</h3><p>js中拖拽的最常见实现思路很清晰，mousedown时改变一个变量的状态，mousemove时看这个变量的状态表示正在拖拽的话就根据鼠标坐标改变被拖拽元素的位置，mouseup时把变量状态变成表示未拖拽即可。<br>具体到这个练习中，mousedown时先判断按下的点是否有曲线的点，canvas有<code>isPointInPath</code>方法，但是这个方法只能判断点，而我的曲线点是有半径的小圆。所以用我定义好的<code>isSameNode</code>函数用距离判断，在两个半径距离以内的都属于重合（两个圆外切的最小圆心距就是两个圆的半径之和，这里两个圆半径一样）。如果有曲线就记下它在所有曲线（数组存储）的索引<code>draggingNodeIndex</code>和当前位置<code>lastLoc</code>。<br>然后是mousemove，这个前面已经说了。<br>mouseup的时候<code>draggingNodeIndex</code>变回-1，也就是没有被拖拽的状态。不过还要再判断一下放下的这里有没有点已经在这儿了，如果有，被拖拽的点就回到<code>lastLoc</code>存储的旧位置中去。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个练习实现起来没什么难度，我是用requirejs来模块化的，感觉不错。<br><a href="http://hunnble.github.io/JavaScript_demo/bezier-drawer/index.html">demo地址，双击创建新点/画曲线/曲线消失</a><br><a href="https://github.com/hunnble/JavaScript_demo/tree/gh-pages/bezier-drawer" target="_blank" rel="external">源码地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在github上follow了好多很厉害的前端er，有一位有个好多star的repo里面就是各种canvas的小练习，canvas玩好了还是有好处的，毕竟前端要是每天光操作操作dom甚至切切页面是没什么长进的，甚至会被写CRUD的童鞋嘲讽。于是我今天又什么都没做，就写了一个画贝塞尔曲线的练习。
    
    </summary>
    
      <category term="frontend" scheme="http://hunnble.github.io/category/frontend/"/>
    
      <category term="demo" scheme="http://hunnble.github.io/category/frontend/demo/"/>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="canvas" scheme="http://hunnble.github.io/tag/canvas/"/>
    
  </entry>
  
  <entry>
    <title>React-redux实践</title>
    <link href="http://hunnble.github.io/2016/08/01/React-redux%E5%AE%9E%E8%B7%B5/"/>
    <id>http://hunnble.github.io/2016/08/01/React-redux实践/</id>
    <published>2016-08-01T09:16:56.000Z</published>
    <updated>2016-11-30T16:16:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于复杂的单页面应用，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。如果 state 变化不可预测，就会难于调试（state 不易重现，很难复现一些 bug）和不易于扩展（比如，优化更新渲染、服务端渲染、路由切换时获取数据等等）。<br>redux解决了state的问题<a id="more"></a>，它的特点沿袭了flux，主要有：</p>
<ul>
<li>state 以单一对象存储在 store 对象中</li>
<li>state 只读</li>
<li>使用纯函数 reducer 执行 state 更新</li>
</ul>
<blockquote>
<p>state 为单一对象，使得 Redux 只需要维护一棵状态树，服务端很容易初始化状态，易于服务器渲染。state 只能通过 dispatch(action) 来触发更新，更新逻辑由 reducer 来执行。</p>
</blockquote>
<p><img src="http://staltz.com/img/redux-unidir-ui-arch.jpg" alt="redux"><br>图来自 <a href="http://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="external">UNIDIRECTIONAL USER INTERFACE ARCHITECTURES</a></p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action一般是向store传递用户的交互信息。dispatch一个action是一个同步的过程，更新 state -&gt; 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。</p>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>reducer 实际上就是一个函数：<code>(previousState, action) =&gt; newState</code>。用来执行根据指定 action 来更新 state 的逻辑。通过 <code>combineReducers(reducers)</code> 可以把多个 reducer 合并成一个 root reducer。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>state的主要特征：</p>
<ul>
<li>管理应用的 state</li>
<li>通过 <code>store.getState()</code> 可以获取 state</li>
<li>通过 <code>store.dispatch(action)</code> 来触发 state 更新</li>
<li>通过 <code>store.subscribe(listener)</code> 来注册 state 变化监听器</li>
<li>通过 <code>createStore(reducer, [initialState])</code> 创建<h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3>单页面应用中充斥着大量的异步请求（ajax）。dispatch(action) 是同步的，如果要处理异步 action，需要使用一些中间件。<br>中间件是某种实现特定功能的高阶函数，作用于 dispatch 返回一个新的 dispatch（附加了该中间件功能）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">thunkMiddleware</span>(<span class="params">&#123; dispatch, getState &#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt;</div><div class="line">        <span class="keyword">typeof</span> action === <span class="string">'function'</span> ? action(dispatch, getState) : next(action)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过 thunk-middleware 我们可以看出中间件的一般形式：中间件函数接受两个参数参数： dispatch 和 getState（也就是说中间件可以获取 state 以及 dispatch new action）。中间件一般返回 next(action)。store 的创建过程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> reducer = combineReducers(reducers)</div><div class="line"><span class="keyword">const</span> finalCreateStore = applyMiddleware(promiseMiddleware, warningMiddleware,</div><div class="line">    loggerMiddleWare)(createStore)</div><div class="line"><span class="keyword">const</span> store = finalCreateStore(reducer)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于复杂的单页面应用，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。如果 state 变化不可预测，就会难于调试（state 不易重现，很难复现一些 bug）和不易于扩展（比如，优化更新渲染、服务端渲染、路由切换时获取数据等等）。&lt;br&gt;redux解决了state的问题
    
    </summary>
    
      <category term="Diary" scheme="http://hunnble.github.io/category/Diary/"/>
    
      <category term="PS3" scheme="http://hunnble.github.io/category/Diary/PS3/"/>
    
      <category term="Games" scheme="http://hunnble.github.io/category/Diary/PS3/Games/"/>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
  </entry>
  
  <entry>
    <title>Web Audio API</title>
    <link href="http://hunnble.github.io/2016/07/30/Web-Audio-API/"/>
    <id>http://hunnble.github.io/2016/07/30/Web-Audio-API/</id>
    <published>2016-07-30T13:11:23.000Z</published>
    <updated>2016-12-07T17:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天什么都没干，就看了一个Web Audio的API然后做了个音频可视化的小demo，呃呃，地址在这里。<br><del><a href="http://hunnble.github.io/JavaScript_demo/web-audio/index.html">demo地址(我把音乐删掉了所以demo看不了了)</a></del><br><a id="more"></a></p>
<p>我早就想玩音频可视化了但是以前用html5的audio标签就没有解析音频的接口。然后昨天才知道有Web Audio这个东西。然后我发现audio标签的功能是这个API的子集，这个API跟多媒体啊信号啊有关的实现的属性和方法很多。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API" target="_blank" rel="external">Web Audio MDN文档</a><br>属性和方法太多了，我今天只掌握了用到的几个，而它们都是基于AudioContext的:</p>
<blockquote>
<p>AudioContext接口代表由音频模块构成的音频处理图。音频环境控制其所包含节点的创建和音频处理、解码的执行。进行任何处理前你必需创建一个音频环境，一切操作都在这个环境里进行。</p>
</blockquote>
<p>这个是最主要的~~~<br>我的代码里用一个函数来封装get它，因为很多浏览器会不兼容这个API嘛:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAudioContext</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ac;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ac = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext || <span class="built_in">window</span>.mozAudioContext)();</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'不支持web audio api: '</span> + e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ac;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是AudioContext.createBufferSource方法</p>
<blockquote>
<p>返回AudioBufferSourceNode，它能让AudioContext.decodeAudioData方法解析它的音频数据从而播放。</p>
</blockquote>
<p>AudioContext.createGain方法</p>
<blockquote>
<p>返回GainNode, 起控制音量的作用</p>
</blockquote>
<p>AudioContext.createAnalyser</p>
<blockquote>
<p>AudioContext的createAnalyser()方法能创建一个AnalyserNode，可以用来获取音频时间和频率数据，以及实现数据可视化。</p>
</blockquote>
<p>AudioContext.destination属性</p>
<blockquote>
<p>返回AudioDestinationNode对象，表示当前audio context中所有节点的最终节点，一般表示音频渲染设备。</p>
</blockquote>
<p>简单了解了上面这几个属性和方法以后就可以做出音频可视化+控制音量的小demo了。初始化的方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this.ac = getAudioContext()</span></div><div class="line">Player.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.source = <span class="keyword">this</span>.ac.createBufferSource();</div><div class="line">    <span class="keyword">this</span>.gainNode = <span class="keyword">this</span>.ac.createGain ? <span class="keyword">this</span>.ac.createGain() : <span class="keyword">this</span>.ac.createGainNode();</div><div class="line">    <span class="keyword">this</span>.analyser = <span class="keyword">this</span>.ac.createAnalyser();</div><div class="line">    <span class="keyword">this</span>.gainNode.connect(<span class="keyword">this</span>.ac.destination);</div><div class="line">    <span class="keyword">this</span>.analyser.connect(<span class="keyword">this</span>.gainNode);</div><div class="line">    <span class="keyword">this</span>.source.connect(<span class="keyword">this</span>.analyser);</div><div class="line">    <span class="keyword">this</span>.gainNode.gain.value = <span class="number">0.5</span>;</div><div class="line">    <span class="keyword">this</span>.analyser.fftSize = <span class="keyword">this</span>.arrSize * <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为每个AudioBufferSource都只能start(noteOn)一次，所以每次切歌的时候这个方法都会重新调用生成新的。connect用来连接这些生成的实例。gainNode.gain.value就是音量了，取[0,1]区间的值。<br>整体的流程很简单，就是用XMLHTTPRequest来获取mp3，然后解析播放音频，并且解析出ArrayBuffer来用canvas生成可视化效果。直接放代码吧，写的有点乱，有时间慢慢填新效果吧，这只是个demo。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Player.prototype.playSound = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    self.xhr.abort();</div><div class="line">    self.xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">    self.xhr.responseType = <span class="string">'arraybuffer'</span>;</div><div class="line">    self.xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        self.ac.decodeAudioData(self.xhr.response, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</div><div class="line">            self.isPlaying &amp;&amp; self.stop();</div><div class="line">            self.init();</div><div class="line">            self.source.buffer = buffer;</div><div class="line">            self.source.start ? self.source.start(<span class="number">0</span>) : self.source.noteOn(<span class="number">0</span>);</div><div class="line">            self.visualize();</div><div class="line">            self.isPlaying = <span class="literal">true</span>;</div><div class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(err);</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line">    self.xhr.send();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Player.prototype.changeVolume = <span class="function"><span class="keyword">function</span> (<span class="params">percent</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.gainNode.gain.value = percent;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Player.prototype.stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.source.stop ? <span class="keyword">this</span>.source.stop() : <span class="keyword">this</span>.source.noteOff();</div><div class="line">    <span class="keyword">this</span>.isPlaying = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Player.prototype.visualize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(self.analyser.frequencyBinCount);</div><div class="line">    <span class="keyword">var</span> v = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        self.analyser.getByteFrequencyData(arr);</div><div class="line">        self.draw(arr);</div><div class="line">        self.isPlaying ? RAF(v) : cancelRAF(v);</div><div class="line">    &#125;;</div><div class="line">    RAF(v);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Player.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> perWidth = <span class="keyword">this</span>.canvas.width / <span class="keyword">this</span>.arrSize;</div><div class="line">    <span class="keyword">var</span> perHeight;</div><div class="line">    <span class="keyword">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.height);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.arrSize; ++i) &#123;</div><div class="line">        perHeight = arr[i] / <span class="keyword">this</span>.arrSize / <span class="number">2</span> * <span class="keyword">this</span>.canvas.height;</div><div class="line">        <span class="keyword">this</span>.ctx.fillRect(perWidth * i, <span class="keyword">this</span>.canvas.height - perHeight, perWidth, perHeight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RAF忘了说了，是动画的那个API,RequestAnimationFrame，配合canvas很好用。</p>
<p>嗯，这个API在MDN里也好多没有翻译的页，我在考虑要不要去帮忙翻译几个。<br>关于Audio的js库有个howler，看起来不错的，如果业务代码里要加音频什么的还是推荐用这种库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天什么都没干，就看了一个Web Audio的API然后做了个音频可视化的小demo，呃呃，地址在这里。&lt;br&gt;&lt;del&gt;&lt;a href=&quot;http://hunnble.github.io/JavaScript_demo/web-audio/index.html&quot;&gt;demo地址(我把音乐删掉了所以demo看不了了)&lt;/a&gt;&lt;/del&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
  </entry>
  
  <entry>
    <title>身份证号匹配正则</title>
    <link href="http://hunnble.github.io/2016/07/21/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%AD%A3%E5%88%99/"/>
    <id>http://hunnble.github.io/2016/07/21/身份证号匹配正则/</id>
    <published>2016-07-20T19:17:47.000Z</published>
    <updated>2016-07-23T10:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续编写我的正则库cr.js，长了不少知识，比如手机号的格式啊身份证号的格式啊什么的。身份证号我写的是二代身份证，也就是18位的那个。<br><a id="more"></a><br>18位的身份证分成三部分：</p>
<h4 id="1-地区码"><a href="#1-地区码" class="headerlink" title="1.地区码"></a>1.地区码</h4><p>前六位是地区码，跟注册身份证的地点（一般就是出生地）关联，正则表达式就很好写，是这个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\\d&#123;6&#125;'</span></div></pre></td></tr></table></figure></p>
<h4 id="2-出生日期"><a href="#2-出生日期" class="headerlink" title="2.出生日期"></a>2.出生日期</h4><p>中间8位是出生年月日，YYYYMMDD的格式。我本来不打算把日期匹配加到库里了因为用正则匹配这种纯数字的日期还不如用js的内建函数方便。不过既然现在需要用了，也不是不会，而且身份证的年份我只取了19和20开始的，也算降低难度了（也没怎么降啊其实，但是还是自我安慰一下啊哈哈哈）<br>由于2月份的特殊性，所以要判断闰年，判断闰年分能被4整除不能被100整除的情况和能被400整除的情况。<br>先从最普遍的情况开始：每个月都有1号到28号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'(?:(19[0-9]&#123;2&#125;|200[0-9]|201[0-6])(?:(?:(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8]))'</span></div></pre></td></tr></table></figure></p>
<p>你会看到我加了很多?:，这是用非捕获组来优化性能，我也是第一次这么用。<br>下面又是两种比较好写的情况：除二月之外的其它月份有29号和30号，13578十腊有31号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'(?:(?:0[13-9]|1[0-2])(?:29|30))|(?:0[13578]|1[02])31))'</span></div></pre></td></tr></table></figure></p>
<p>好了下面是BOSS关<br>我先把表达式写出来，我得看着写~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'(?:(?:(19|20)(?:0[48]|[2468][048]|[13579][26]))|2000)0229'</span></div></pre></td></tr></table></figure></p>
<p>啊，其实也不长哈，我怎么错了那么多次才写好…<br>只需要19和20开头的年份，<code>(0[48]|[2468][048]|[13579][26])</code>是能被4整除不能被100整除的后两位，而另一种情况是能被400整除的，如果是从公园0年开始计的话应该是<code>(0[48]|[2468][048]|[13579][26])00</code>这样的，后两位肯定是00，前两位能被4整除就可以。然而我只用(1900, 2016]这个区间，所以符合的只有2000这一个。<br>最后再放上<code>0229</code>。<br>最后的最后把这几个小串用<code>|</code>连接起来。</p>
<h4 id="3-最后4位"><a href="#3-最后4位" class="headerlink" title="3.最后4位"></a>3.最后4位</h4><p>光用地区和日期区分肯定会有很多同年同月同日同地区出生的人重合，所以后四位是区分码，其中第三位，也就是身份证的第十七位遵守男单数女双数的规则。最后一位也就是身份证的第十八位除了阿拉伯数字之外还可以出现大写英文字母X。<br>所以这么匹配就好了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'([0-9]&#123;3&#125;[0-9X])'</span></div></pre></td></tr></table></figure></p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>我上面写的都是字符串形式的，所以最后把字符串合并，然后用它创建新的RegExp实例就可以了。<br>详细代码点<a href="https://github.com/hunnble/common_regexps/blob/master/index.js" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续编写我的正则库cr.js，长了不少知识，比如手机号的格式啊身份证号的格式啊什么的。身份证号我写的是二代身份证，也就是18位的那个。&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="regexp" scheme="http://hunnble.github.io/tag/regexp/"/>
    
  </entry>
  
  <entry>
    <title>几种跨域的方法</title>
    <link href="http://hunnble.github.io/2016/07/11/%E5%87%A0%E7%A7%8D%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://hunnble.github.io/2016/07/11/几种跨域的方法/</id>
    <published>2016-07-11T13:49:20.000Z</published>
    <updated>2016-07-13T02:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>谈到前端肯定少不了Ajax,谈到Ajax肯定少不了跨域。诗兴大发的我很想说一句，哦，跨域，你就像毒蛇一样，美丽而又危险。<br>今天写小玩具的时候又遇到跨域问题，索性先粗略总结一下跨域的一些方法。<br><a id="more"></a></p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>我刚开始学Ajax的时候要写demo练习嘛，所以就用世界上最好的语言php在后端echo一些数据。比如这样的：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin:./js/create_data.js"</span>);</div><div class="line">$test_obj1 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">2</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试一, data类型为数组"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading1"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="keyword">Array</span>(<span class="string">"aaaaaaaaaaaaa"</span>, <span class="string">"bbbbbbbbbbbbbb"</span>, <span class="string">"ccccccccccc"</span>)</div><div class="line">);</div><div class="line">$test_obj2 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">4</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试二, data类型为键值对(对象)"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading2"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="keyword">array</span>(</div><div class="line">        <span class="string">"aaa"</span>=&gt; <span class="string">"aaaaaa"</span>,</div><div class="line">        <span class="string">"bbb"</span>=&gt; <span class="string">"bbbbbbbbb"</span></div><div class="line">    )</div><div class="line">);</div><div class="line">$test_obj3 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">5</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试三, data类型为字符串(暂时不进行trim和过滤特殊字符操作)"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading3"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="string">"cccccccc！！！"</span></div><div class="line">);</div><div class="line">$test_obj4 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">5</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试四, data类型为含有对象的数组"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading4"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="keyword">Array</span>(<span class="string">"data1"</span>, <span class="keyword">array</span>(<span class="string">"data2"</span>=&gt; <span class="string">"data2value"</span>), <span class="string">"data3"</span>)</div><div class="line">);</div><div class="line">$test_obj5 = <span class="keyword">array</span> (</div><div class="line">    <span class="string">'rank'</span>=&gt; <span class="number">5</span>,</div><div class="line">    <span class="string">'title'</span>=&gt; <span class="string">"测试五 data类型为含有数组的对象"</span>,</div><div class="line">    <span class="string">'describe'</span>=&gt; <span class="string">"subheading5"</span>,</div><div class="line">    <span class="string">'data'</span>=&gt; <span class="keyword">array</span>(</div><div class="line">        <span class="string">'data1'</span>=&gt; <span class="string">"data1value"</span>,</div><div class="line">        <span class="string">'data2'</span>=&gt; <span class="keyword">Array</span>(<span class="string">"data2"</span>, <span class="string">"data3"</span>)</div><div class="line">    )</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> json_encode(<span class="keyword">Array</span>($test_obj1, $test_obj2, $test_obj3, $test_obj4, $test_obj5));</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>第一次写的时候没有加第二行的那个添加http头的语句，在运行的时候就报错，因为我当时测试当然是在本地，本地不同文件夹不在同一域内，这就形成了跨域。<br>而聪明的我机智地找到了破解之法，那就是给php手动设置Access-Control-Allow-Origin，允许我前端的文件去访问，再次在前端get，成功得到数据。这种方法叫做CORS（跨域资源共享，Cross-Origin Resource Sharing），这种方法比较方便，浏览器的兼容性也不错，被广泛运用在移动端。<br>但是不能满足于此，比如今天我遇到的问题是要用豆瓣的读书API，总不能给豆瓣API小组打电话说：“嗨，给我加一行代码吧我跨域了解决不了了在线等挺急的。”吧。所以说打铁还需自身硬（这句话怎么怪怪的），一定有别的方法可以（在一定程度上）直接解决跨域问题。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP吧，这个方法很强大滴。<br>今天想玩玩豆瓣API，给自己正在用express做的一个书单（叫图书管理系统总是有种浓浓的大作业风）应用加点内容，然后去<a href="https://developers.douban.com/wiki/?title=book_v2" target="_blank" rel="external">豆瓣API文档</a>看了看就开始写了。为了简洁还是用上了jQuery，今天试的是根据图书名来获取图书信息。<br>路由：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">'/book/:name/:author'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  book.get(req.params.name, req.params.author, <span class="function"><span class="keyword">function</span> (<span class="params">err, _book</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!_book) &#123;</div><div class="line">      req.flash(<span class="string">'error'</span>, <span class="string">'获取书籍信息失败'</span>);</div><div class="line">      <span class="keyword">return</span> res.redirect(<span class="string">'/'</span>);</div><div class="line">    &#125;</div><div class="line">    res.render(<span class="string">'book'</span>, &#123;</div><div class="line">      <span class="attr">title</span>: _book.name,</div><div class="line">      <span class="attr">user</span>: req.session.user,</div><div class="line">      <span class="attr">success</span>: req.flash(<span class="string">'success'</span>).toString(),</div><div class="line">      <span class="attr">error</span>: req.flash(<span class="string">'error'</span>).toString()</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这段代码用不着读懂，因为有我自己在别处定义的方法，大概的功能就是先去数据库里找有没有添加过name是参数name的书，有的话就渲染ejs模版book.ejs。重点在下面。<br>不在后端调用API而放在前端用Ajax是因为Ajax是随时想再获取就可以立刻获取嘛比如到时候用户向下浏览到底的时候就可以动态再加载一些数据，写在后端就要refresh整个页面了相当，Ajax的优势就体现在这儿了。<br>前端的处理我使用了JSONP，先讲原理然后放上代码就不用解释了，哈哈。<br>JSONP是JSON with padding（填充式JSON）的简写，意思就是被包裹在函数中的json：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callback (&#123;<span class="string">'name'</span>: <span class="string">'Tyrion'</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的网名字一般在请求中指定。数据则是传入回调函数中的JSON。<br>JSONP的实现是动态添加一个script标签，它是可以跨域的，给它的src属性指定为要访问的url即可。<br>在jQuery中，使用JSONP十分方便，只需要在ajax方法中改动几处。接着上面的代码来看我的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 调用豆瓣搜索书API并解析获取的json数据，动态渲染页面。</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBook</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="built_in">window</span>.location.pathname.split(<span class="string">'/'</span>)[<span class="number">2</span>];</div><div class="line"></div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">'GET'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'https://api.douban.com/v2/book/search?q='</span> + name,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'jsonp'</span>,</div><div class="line">        <span class="attr">jsonp</span>: <span class="string">'callback'</span>,</div><div class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">            <span class="comment">// result就是豆瓣返回的json数据了。下面就可以使用数据来做事情...</span></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>name是从页面的url中取的name参数。<br>注意将数据类型指定为’jsonp’和指定jsonp: ‘callback’。</p>
<h3 id="img-Ping"><a href="#img-Ping" class="headerlink" title="img Ping"></a>img Ping</h3><p>这个没什么好说的啦，原理就是动态加一个img标签，跟JSONP一个道理。但是和script不同，img无法对响应文本进行处理，所以只能用于get。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Done</span></div><div class="line">&#125;;</div><div class="line">img.src = <span class="string">'http://www.targetUrl.com?name=Tyrion'</span>;</div></pre></td></tr></table></figure></p>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>名字起的不错哈哈哈，<del>反正自从我用过celery后其它的框架啊库啊还有技术名词我都觉得挺好的</del><br>Comet在这个语境下指的是服务器推送，是服务器段向客户端推送数据的技术。<br>有两种实现Comet的方式：长轮询和流，根据名字应该已经能知道它们的实现方式了。这个我还没有用过，就不不懂装懂了。</p>
<h3 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h3><p>这个技术似乎被评价得很高，它是一个新浏览器API，可以现在浏览器和服务器之间提供一个单独而持久的连接，是基于HTTP而升级成的网Web Socket协议的连接。所以服务器需要是支持这个协议的。<br>Web Sockets提供一套API来实现，过段时间我学完会回来填坑的。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>放假回来一周了，每天晚上一点多都要习惯性地看一下电脑的电量然后看到是百分之百就会愣一下。同时看几本书所以导致一周下来都没有看到一半以上的所以潜意识里有点消沉，但是又都想看，但愿下周能看完最薄的一本哈哈哈。<br>好久没写css了再写的时候用LESS玩玩吧，感觉文档也不多，也有用过scss所以应该会很容易上手吧哈哈哈，也不知道它的媒体查询那块简洁不简洁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谈到前端肯定少不了Ajax,谈到Ajax肯定少不了跨域。诗兴大发的我很想说一句，哦，跨域，你就像毒蛇一样，美丽而又危险。&lt;br&gt;今天写小玩具的时候又遇到跨域问题，索性先粗略总结一下跨域的一些方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
  </entry>
  
  <entry>
    <title>ES6-函数的扩展</title>
    <link href="http://hunnble.github.io/2016/07/05/ES6-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://hunnble.github.io/2016/07/05/ES6-函数的扩展/</id>
    <published>2016-07-05T02:41:30.000Z</published>
    <updated>2016-07-06T10:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>js中函数是“一等公民”，ES6标准对函数做了一些扩展使得熟悉其它语言的程序员可以更快地上手，而js程序员也会发现函数更强大也更便于编写了。<br><a id="more"></a></p>
<h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>很多语言都支持函数有默认值，比如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span> <span class="params">(x = <span class="number">10</span>)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>ES6也引入了函数默认参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x = <span class="number">50</span>, y</span>) </span>&#123;</div><div class="line">    <span class="comment">// x: 50, y: undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>给参数指定默认值后，该参数及之后的参数不会被函数的length计数（rest参数也不会计数）。且有默认值的参数都不是尾参数，无法跳过，在调用函数的时候只能写undefined跳过。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y = <span class="number">50</span>, z</span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">...args</span>) </span>&#123;&#125;</div><div class="line">foo.length <span class="comment">// 1 =&gt; 只有x被计入length</span></div><div class="line">bar.length <span class="comment">// 0</span></div></pre></td></tr></table></figure></p>
<p>而可以省略参数时，也可以将参数默认值设置成undefined。</p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点…，作用是将一个数组转为参数序列。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// 1 2 3</span></div></pre></td></tr></table></figure></p>
<p>扩展运算符的主要用途是解构rest参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</div><div class="line">    array.push(...items);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>函数的name属性返回该函数的函数名。<br>将具名函数赋值给一个变量，name属性返回具名函数的名字。<br>Function构造函数返回的函数实例，name属性的值为”anonymous”。<br>bind返回的函数name属性值会加上”bound “前缀。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> f4 = <span class="function"><span class="keyword">function</span> <span class="title">f3</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> f5 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f1.name, f2.name, f4.name, (<span class="keyword">new</span> <span class="built_in">Function</span>).name, f5.bind(&#123;&#125;).name); <span class="comment">// f1 f2 f3 anonymous bound f5</span></div></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6允许使用箭头定义函数，箭头长这样: =&gt;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> result;</div></pre></td></tr></table></figure></p>
<p>这种是最简单的形式，参数列表加返回值。<br>如果代码部分多于一条语句就要用大括号了，且要写return。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> arg1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于大括号被解释成代码块，所以返回的是对象的时候为了区分，要在对象外面加上括号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">a</span> =&gt;</span> (&#123;<span class="attr">r1</span>: a&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>箭头函数可以绑定this对象，淘汰了显式绑定this对象的写法，如call,apply,bind等。</li>
<li>函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象。原因是上一条的箭头函数自身没有this，所以this总是指定义时所在的对象。</li>
<li>不可以当作构造函数，即不可以使用new命令。原因也是自身没有this。</li>
<li>没有arguments对象了，喜闻乐见。</li>
<li>不可以使用yield命令，即不能作为Generator函数。</li>
</ul>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用是函数式编程的一个概念，就是指某个函数的最后一步是调用另一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> g(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数调用会在内部形成调用帧（call frame）用以保存调用位置和内部变量等信息，如果在函数A的内部调用函数B，那么B的调用帧会在A的调用帧上方。以此类推，调用帧会形成栈的数据结构，称为调用栈（call stack）。<br>由于尾调用是外部函数最后一次操作，所以可以如下优化：用内层函数的调用帧取代外层函数的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>  <span class="title">f</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> m = <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> n = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> g(m + n);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> g(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">g(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js中函数是“一等公民”，ES6标准对函数做了一些扩展使得熟悉其它语言的程序员可以更快地上手，而js程序员也会发现函数更强大也更便于编写了。&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6-数组的扩展</title>
    <link href="http://hunnble.github.io/2016/06/30/ES6-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://hunnble.github.io/2016/06/30/ES6-数组的扩展/</id>
    <published>2016-06-30T02:38:03.000Z</published>
    <updated>2016-06-30T15:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6对Array的扩展<br><a id="more"></a></p>
<h3 id="from方法"><a href="#from方法" class="headerlink" title="from方法"></a>from方法</h3><p>Array.from方法用于将类似数组的对象（array-like object）和可遍历对象（iterable）转化为真正的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arrayLike = &#123;</div><div class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="string">'o'</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="string">'e'</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> arrES5 = [].slice.call(arrayLike); <span class="comment">// ['a', 'o', 'e']</span></div><div class="line"><span class="keyword">let</span> arrES6 = arrayLike.from(arrayLike); <span class="comment">// ['a', 'o', 'e']</span></div><div class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.from(<span class="string">'aoe'</span>); <span class="comment">// ['a', 'o', 'e']</span></div></pre></td></tr></table></figure></p>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合以及函数内部的arguments对象，Array.form可以将它们转换成真正的数组。<br>Array.from的用处在于，将各种值转为数组后，可以有效使用各种数组方法来处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回参数类型组成的数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typesOf</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, value =&gt; <span class="keyword">typeof</span> value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一个应用是将字符串转为数组来求长度，绕过了Unicode的\uFFFF限制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span> (<span class="params">string</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="of方法"><a href="#of方法" class="headerlink" title="of方法"></a>of方法</h3><p>Array.of方法将一组值转换为数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// [2, 3, 4]</span></div></pre></td></tr></table></figure></p>
<h3 id="copyWithin方法"><a href="#copyWithin方法" class="headerlink" title="copyWithin方法"></a>copyWithin方法</h3><p>Array.prototype.copyWithin将当前数组内部指定位置的成员复制到其它位置（会覆盖原有成员），然后返回当前数组。它接受三个参数：target, start = 0, end = this.length</p>
<ul>
<li>target（必需）： 从这个位置开始替换数据。</li>
<li>start：从这个位置开始读取数据，负值表示倒数</li>
<li>end：到这个位置停止读取数据。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-3</span>) <span class="comment">// [4,5,3,4,5]</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-3</span>) <span class="comment">// [3,4,5,4,5]</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [4,2,3,4,5]</span></div></pre></td></tr></table></figure>
<h3 id="find-findIndex方法"><a href="#find-findIndex方法" class="headerlink" title="find,findIndex方法"></a>find,findIndex方法</h3><p>find方法用于找出数组中第一个符合条件的数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].find(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value &gt; <span class="number">3</span>;</div><div class="line">&#125;) <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>findIndex则是返回索引值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value &gt; <span class="number">3</span>;</div><div class="line">&#125;) <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h3 id="fill方法"><a href="#fill方法" class="headerlink" title="fill方法"></a>fill方法</h3><p>fill方法使用给定值填充数组，第二个参数指定填充的起始位置，第三个参数指定填充的结束位置。</p>
<h3 id="entries-keys-values方法"><a href="#entries-keys-values方法" class="headerlink" title="entries,keys,values方法"></a>entries,keys,values方法</h3><p>这三个方法都用于遍历数组，返回值都是遍历器对象，区别是：entries是对键值对的遍历，keys是对键名的遍历，而values是对键值的遍历。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'o'</span>, <span class="string">'e'</span>].entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(index + <span class="string">':'</span> + elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0:a</span></div><div class="line"><span class="comment">// 1:o</span></div><div class="line"><span class="comment">// 2:e</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'o'</span>, <span class="string">'e'</span>].keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'o'</span>, <span class="string">'e'</span>].values()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'o'</span></div><div class="line"><span class="comment">// 'e'</span></div></pre></td></tr></table></figure></p>
<h3 id="includes方法"><a href="#includes方法" class="headerlink" title="includes方法"></a>includes方法</h3><p>Array.prototype.includes方法返回一个布尔值，表示数组是否包含给定值。第二个参数表示搜索的起始位置。</p>
<h3 id="对数组空位的处理"><a href="#对数组空位的处理" class="headerlink" title="对数组空位的处理"></a>对数组空位的处理</h3><p>书上说，数组各方法对数组空位的处理是有区别的，不过大部分都是忽略二字。</p>
<ul>
<li>forEach(),filter(),every()和some():跳过空位</li>
<li>map():跳过，但是保留值</li>
<li>join()和toString():将空位当做undefined处理</li>
<li>from():将空位转为undefined</li>
<li>copyWithin():不忽略空位，也会一视同仁地复制</li>
<li>fill():不跳过空位，空位也会被填充</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6对Array的扩展&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6-数值的扩展</title>
    <link href="http://hunnble.github.io/2016/06/28/ES6-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://hunnble.github.io/2016/06/28/ES6-数值的扩展/</id>
    <published>2016-06-28T15:44:55.000Z</published>
    <updated>2016-06-29T01:12:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS的数值设计的不好，嗯，但是ES6说，还可以抢救一下…<br><a id="more"></a></p>
<h3 id="二进制和八进制和十六进制…"><a href="#二进制和八进制和十六进制…" class="headerlink" title="二进制和八进制和十六进制…"></a>二进制和八进制和十六进制…</h3><p>从ES5开始，在严格模式中，八进制数值就不再允许使用前缀0表示，ES6进一步明确，要使用前缀0o表示。同理，二进制使用0B前缀。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">0b11</span> === <span class="number">3</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">9</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>而16进制依然是0x前缀。<br>要将8进制和16进制的数值转化成10进制可以使用Number:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>(<span class="number">0o11</span>) <span class="comment">// 9</span></div><div class="line"><span class="built_in">Number</span>(<span class="number">0x11</span>) <span class="comment">// 17</span></div></pre></td></tr></table></figure></p>
<h3 id="判断Infinite-NaN"><a href="#判断Infinite-NaN" class="headerlink" title="判断Infinite,NaN"></a>判断Infinite,NaN</h3><p>ES6对Number对象提供了isFinite和isNaN两个方法来检查Infinite和NaN两个特殊值，又算是填上了一个坑。<br>这两个方法和原来的同名全局方法的区别在于：传统方法将非数值一律转为数值再判断，而新方法对非数值一律返回false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="string">'100'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="string">'100'</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger"></a>Number.isInteger</h3><p>判断一个数是否是整数</p>
<h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>一个很小的数，是常量。值是2.220446049250313e-16。<br>我们知道JS存数是按浮点型地存，所以数值运算常常有误差，ES6规定吗，误差比EPSILON小就认为得到了正确结果。</p>
<h3 id="安全整数"><a href="#安全整数" class="headerlink" title="安全整数"></a>安全整数</h3><p>话说,坑好多呀…<br>JS能精确表示的正数范围是-2^[53]—2^[53]，超过就无法精确表示了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)); <span class="comment">// 9007199254740992</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>); <span class="comment">// 还是9007199254740992</span></div></pre></td></tr></table></figure></p>
<p>Number引入了MAX_SAFE_INTEGER和MIN_SAFE_INTEGER来表示上面说的两个临界值，以及isSafeInteger方法来判断数是否在这个闭区间内。</p>
<h3 id="Math对象扩展"><a href="#Math对象扩展" class="headerlink" title="Math对象扩展"></a>Math对象扩展</h3><p>Math对象上都是些数学相关方法，ES6新增了16个，我不打算记录下来了，因为由于水平所限，实际应用中还没有遇到过需要这些方法的情况。</p>
<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符**"></a>指数运算符**</h3><p>刚才又有用Math.pow,现在来说一下**这个运算符，它叫指数运算符，就是来算幂指数的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">3</span>); <span class="comment">// 8</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS的数值设计的不好，嗯，但是ES6说，还可以抢救一下…&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6-RegExp扩展</title>
    <link href="http://hunnble.github.io/2016/06/27/ES6-RegExp%E6%89%A9%E5%B1%95/"/>
    <id>http://hunnble.github.io/2016/06/27/ES6-RegExp扩展/</id>
    <published>2016-06-27T14:39:50.000Z</published>
    <updated>2016-06-27T16:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6扩展了JavaScript中的正则<br><a id="more"></a></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ES5中的RegExp只能接收字符串作为参数，ES6中接收正则表达式作为参数，返回原有正则表达式的拷贝<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>);</div></pre></td></tr></table></figure></p>
<p>另外，第二个参数可以改变修饰符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">"i"</span>);</div></pre></td></tr></table></figure></p>
<p>但是在使用gulp转化ES6到ES5后代码还是形如上面这样，所以浏览器按ES5解释后报错，也许是转的有问题。</p>
<h3 id="字符串方法交给正则表达式对象"><a href="#字符串方法交给正则表达式对象" class="headerlink" title="字符串方法交给正则表达式对象"></a>字符串方法交给正则表达式对象</h3><p>match, replace, search, split是String对象的四个可以调用正则表达式的方法，ES6将这四个方法分别编程调用RegExp上的Symbol.*方法。</p>
<h3 id="新增修饰符"><a href="#新增修饰符" class="headerlink" title="新增修饰符"></a>新增修饰符</h3><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><p>新增的u修饰符含义为”Unicode模式”，上篇博客（ES-字符串）介绍了Es6对Unicode的0xFFFF限制没有了， 以及可以用大括号表示Unicode字符，在正则中用u修饰符来开启这些功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>); <span class="comment">// false</span></div><div class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>); <span class="comment">// true</span></div><div class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">'a'</span>)；<span class="comment">// false</span></div><div class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">'a'</span>)；<span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 正确返回字符串长度的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = str.match(<span class="regexp">/[\s\S]/gu</span>);</div><div class="line">    <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h4><p>y修饰符是粘连（sticky）修饰符，也不知道为什么要用y这个字母。<br>y修饰符和g修饰符类似，都是全局匹配，但是不同于g修饰符每次匹配的时候只需要剩余未匹配位置中存在匹配，而y修饰符要求匹配必须从剩余的第一个位置开始，也就是sticky。<br>与y修饰符相配，ES6为正则对象添加了sticky属性，表示是否设置了y修饰符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/y</span>;</div><div class="line">r.sticky <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h3><p>ES6为正则对象添加了flags属性，会返回修饰符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/ig</span>;</div><div class="line">r.source <span class="comment">// "abc"</span></div><div class="line">r.flags <span class="comment">// "ig"</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6扩展了JavaScript中的正则&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6-字符串</title>
    <link href="http://hunnble.github.io/2016/06/25/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://hunnble.github.io/2016/06/25/ES6-字符串/</id>
    <published>2016-06-25T15:23:09.000Z</published>
    <updated>2016-06-25T16:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6扩展了很多字符串的属性和方法。<br><a id="more"></a></p>
<h3 id="大括号表示Unicode字符"><a href="#大括号表示Unicode字符" class="headerlink" title="大括号表示Unicode字符"></a>大括号表示Unicode字符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> t = <span class="string">"\uD842\uDFB7"</span>;</div><div class="line"><span class="keyword">let</span> t1 = <span class="string">"\u&#123;20BB7&#125;"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(t, t1); <span class="comment">//𠮷 𠮷</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'\u&#123;1f680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>现在可以不受0xFFFF的最大限制了，只要把码点放到大括号里就可以正确解读。</p>
<h3 id="codePointAt-fromCodePoint-at"><a href="#codePointAt-fromCodePoint-at" class="headerlink" title="codePointAt, fromCodePoint, at"></a>codePointAt, fromCodePoint, at</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(t.charCodeAt(<span class="number">0</span>)); <span class="comment">// 55362</span></div><div class="line"><span class="built_in">console</span>.log(t.codePointAt(<span class="number">0</span>)); <span class="comment">// 134071</span></div></pre></td></tr></table></figure>
<p>还是因为javascript中对4个字节存储的字符无法正确处理，ES6中对charCodeAt升级出codePointAt方法，可以正确处理4个字节存储的字符了。返回值是32位UTF-16字符的码点。<br>相应的，对于fromCharCode也升级出fromCodePoint方法， charAt升级出at方法。</p>
<h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes, startsWith, endsWith"></a>includes, startsWith, endsWith</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> goodnight = <span class="string">'good night'</span>;</div><div class="line"><span class="built_in">console</span>.log(goodnight.includes(<span class="string">'ood'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(goodnight.startsWith(<span class="string">'good'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(goodnight.endsWith(<span class="string">'night'</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这三个方法都支持第二个参数，includes和startsWith的第二个参数表示开始搜索的位置，而endsWith的第二个参数表示对前n个字符进行处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> goodnight = <span class="string">'good night'</span>;</div><div class="line"><span class="built_in">console</span>.log(goodnight.includes(<span class="string">'ood'</span>, <span class="number">1</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(goodnight.startsWith(<span class="string">'good'</span>, <span class="number">1</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(goodnight.endsWith(<span class="string">'night'</span>, <span class="number">5</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>返回一个新字符串，值是原字符串重复n次<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(goodnight.repeat(<span class="number">10</span>));</div></pre></td></tr></table></figure></p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>使用反引号括起来的字符串称为模板字符串（template string），可以换行的时候保留空格和缩进，还可以使用变量, 将变量名放在${}中即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</div><div class="line">    y = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span></span></div><div class="line">   = ?`</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6扩展了很多字符串的属性和方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6-变量的解构赋值</title>
    <link href="http://hunnble.github.io/2016/06/25/ES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://hunnble.github.io/2016/06/25/ES6-变量的解构赋值/</id>
    <published>2016-06-25T13:05:46.000Z</published>
    <updated>2016-06-25T15:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被成为解构赋值(Destructuring)。<br><a id="more"></a></p>
<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, [b, [c]], , e, ...tail] = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]], <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, [<span class="number">8</span>]];</div><div class="line"><span class="keyword">let</span> [i, j] = [<span class="string">'a'</span>];</div><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(a, b, c, e, tail); <span class="comment">// 1 2 3 6 [7, [8]]</span></div><div class="line"><span class="built_in">console</span>.log(i, j); <span class="comment">// 'a' undefined</span></div><div class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// 1, 2</span></div></pre></td></tr></table></figure>
<p>上面的是对数组的解构赋值，下面写用于对象的。</p>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>对对象的解构赋值要求变量与属性同名，因为对象的属性是不能像数组那样用索引取得的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;s1, s2, s3&#125; = &#123;<span class="attr">s1</span>: <span class="string">'s1'</span>, <span class="attr">s2</span>: <span class="string">'s2'</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(s1, s2, s3); <span class="comment">// s1 s2 undefined</span></div></pre></td></tr></table></figure></p>
<p>解构赋值时会重新声明变量，所以对已经声明的变量解构赋值应该这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s4;</div><div class="line">(&#123;s4&#125; = &#123;<span class="attr">s4</span>: <span class="number">100</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>为什么{s4} = {s4: 100};不行而要套上括号呢？原因在于JavaScript引擎会将{}包围的代码理解成一个代码块，发生syntax error，所以不能将大括号写在行首，套上括号来解决。<br>下面说其它数据类型的解构赋值，直接举栗子吧</p>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [c1, c2, c3] = <span class="string">'let'</span>;</div><div class="line"><span class="built_in">console</span>.log(c1, c2, c3); <span class="comment">// 'l' 'e' 't'</span></div></pre></td></tr></table></figure>
<h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">[x1, x2]</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x1 + x2;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add([<span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被成为解构赋值(Destructuring)。&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6-let and const</title>
    <link href="http://hunnble.github.io/2016/06/24/ES6-let-and-const/"/>
    <id>http://hunnble.github.io/2016/06/24/ES6-let-and-const/</id>
    <published>2016-06-24T14:58:32.000Z</published>
    <updated>2016-06-24T15:38:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>es6学习笔记第一篇，let和const命令<br><a id="more"></a></p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>ES6新增了let命令，用于声明变量，但是它和var是有区别的。区别在于，它只在块级作用域内有效，而var呢，由于众所周知的语言特性，var声明的变量在函数作用域内有效（参考你不知道的javascript中没有块级作用域章节）。<br>let的使用使从前需要用IIFE解决的一些问题变得不再是问题了，比如下面的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> m = tasks.length - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m--) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">        <span class="comment">//TODO</span></div><div class="line">    &#125;)(m);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于使用var声明的变量在循环中会被一次次地覆盖，如果不使用上面的解决方法，最终每次loop都处理的是m=0也就是最后一次的情况。IIFE能保存每一次的m不被回收掉，在let出现之前这是一个较优解。<br>如果使用let呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> m = tasks.length - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m--) &#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和写c++呀java呀什么的一样啦~<br>于是js又少了一个被黑的点（没有块作用域）<br>let的其他特点：<br>1.不存在变量提升</p>
<ul>
<li>变量在声明前使用会报ReferenceError，也就是说形成了暂时性死区（temporal dead zone），简称TDZ<br>2.不允许在相同作用域内重复声明同一个变量</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const用来声明常量，一旦声明就不能改变，修改const声明的常量会报TypeError，只声明不赋值会报SyntaxError。<br>其他方面const和let基本一致：只在块作用域内有效，不存在变量提升，形成TDZ，不允许在相同作用域内重复声明。<br>然而看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = &#123;&#125;;</div><div class="line">foo.prop = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo.prop); <span class="comment">// 123</span></div></pre></td></tr></table></figure></p>
<p>这个例子是可以运行的，是不是感觉不太对劲，foo是常量为什么可以改变？<br>原因：对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const之保证指向的地址不变，并不保证该地址的数据不变。上面的例子中foo始终指向一个Object实例的地址，这个是不变的，但是实例本身加了属性prop，const就要不起了。</p>
<h3 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h3><p>一句话，var和function声明的变量原来在ES5中是全局对象的属性，ES6尊重这一点，没有变。但let和const（包括class）声明的就不属于了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> varObj = <span class="number">1024</span>;</div><div class="line"><span class="built_in">console</span>.log(varObj) <span class="comment">// 1024</span></div><div class="line"><span class="keyword">let</span> letObj = <span class="number">1024</span>;</div><div class="line"><span class="built_in">console</span>.log(letObj) <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;es6学习笔记第一篇，let和const命令&lt;br&gt;
    
    </summary>
    
    
      <category term="frontend" scheme="http://hunnble.github.io/tag/frontend/"/>
    
      <category term="es6" scheme="http://hunnble.github.io/tag/es6/"/>
    
      <category term="ES6标准入门学习笔记" scheme="http://hunnble.github.io/tag/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>async库waterfall源码分析</title>
    <link href="http://hunnble.github.io/2016/06/21/async%E5%BA%93waterfall%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://hunnble.github.io/2016/06/21/async库waterfall源码分析/</id>
    <published>2016-06-21T14:32:49.000Z</published>
    <updated>2016-06-21T14:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天重构node.js博客代码的时候为了把好几层的嵌套消除就使用了大名鼎鼎的aysnc库中的waterfall函数。<a id="more"></a>使用async前画风是这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">User.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">name, callback</span>) </span>&#123;</div><div class="line">    mongodb.open(<span class="function"><span class="keyword">function</span> (<span class="params">err, db</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">return</span> callback(err);</div><div class="line">        &#125;</div><div class="line">        db.collection(DBNAME, <span class="function"><span class="keyword">function</span> (<span class="params">err, collection</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                mongodb.close();</div><div class="line">                <span class="keyword">return</span> callback(err);</div><div class="line">            &#125;</div><div class="line">            collection.findOne(&#123;</div><div class="line">                <span class="attr">name</span>: name</div><div class="line">            &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</div><div class="line">                mongodb.close();</div><div class="line">                <span class="keyword">if</span> (err) &#123;</div><div class="line">                    <span class="keyword">return</span> callback(err);</div><div class="line">                &#125;</div><div class="line">                callback(<span class="literal">null</span>, user);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用async后画风变成这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">User.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">name, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">async</span>.waterfall([</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">            mongodb.open(<span class="function"><span class="keyword">function</span> (<span class="params">err, db</span>) </span>&#123;</div><div class="line">                cb(err, db);</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">db, cb</span>) </span>&#123;</div><div class="line">            db.collection(DBNAME, <span class="function"><span class="keyword">function</span> (<span class="params">err, collection</span>) </span>&#123;</div><div class="line">                cb(err, collection);</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">collection, cb</span>) </span>&#123;</div><div class="line">            collection.findOne(&#123;</div><div class="line">                <span class="attr">name</span>: name</div><div class="line">            &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</div><div class="line">                cb(err, user);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    ], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</div><div class="line">        mongodb.close();</div><div class="line">        <span class="keyword">if</span>(err) &#123;</div><div class="line">            <span class="keyword">return</span> callback(err);</div><div class="line">        &#125;</div><div class="line">        callback(<span class="literal">null</span>, result[<span class="number">0</span>]);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>哈哈哈！<br>那么waterfall的源码长这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span>.waterfall = <span class="function"><span class="keyword">function</span> (<span class="params">tasks, callback</span>) </span>&#123;</div><div class="line">        callback = callback || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">        <span class="keyword">if</span> (!_isArray(tasks)) &#123;</div><div class="line">          <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'First argument to waterfall must be an array of functions'</span>);</div><div class="line">          <span class="keyword">return</span> callback(err);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!tasks.length) &#123;</div><div class="line">            <span class="keyword">return</span> callback();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> wrapIterator = <span class="function"><span class="keyword">function</span> (<span class="params">iterator</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (err) &#123;</div><div class="line">                    callback.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">                    callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">                    <span class="keyword">var</span> next = iterator.next();</div><div class="line">                    <span class="keyword">if</span> (next) &#123;</div><div class="line">                        args.push(wrapIterator(next));</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        args.push(callback);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">async</span>.setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                        iterator.apply(<span class="literal">null</span>, args);</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        wrapIterator(<span class="keyword">async</span>.iterator(tasks))();</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>其中的iterator函数是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span>.iterator = <span class="function"><span class="keyword">function</span> (<span class="params">tasks</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> makeCallback = <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (tasks.length) &#123;</div><div class="line">                    tasks[index].apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> fn.next();</div><div class="line">            &#125;;</div><div class="line">            fn.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> (index &lt; tasks.length - <span class="number">1</span>) ? makeCallback(index + <span class="number">1</span>): <span class="literal">null</span>;</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">return</span> fn;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> makeCallback(<span class="number">0</span>);</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>waterfall开头先对第一个参数做限制，必须是function数组，接下来的wrapIterator封装了iterator，执行后返回的是一个匿名function。其明确的参数只有一个err。当err不为空的时候，直接执行callback function。否则从index为1开始取出参数列表，并把iterator的下一个function包装之后push到args中（如果没有下一个function了则push回调函数）。接下来，则执行当前的iterator，执行的参数是下一个iterator function（作为这一步的回调函数）以及参数（如果当前的iterator被调用时传递了其他参数）。这样在当前iterator中回调下一个iterator，依次迭代执行，直至执行完所有function和callback。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天重构node.js博客代码的时候为了把好几层的嵌套消除就使用了大名鼎鼎的aysnc库中的waterfall函数。
    
    </summary>
    
    
      <category term="node.js" scheme="http://hunnble.github.io/tag/node-js/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://hunnble.github.io/2016/06/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://hunnble.github.io/2016/06/17/HTTP状态码/</id>
    <published>2016-06-17T15:45:18.000Z</published>
    <updated>2016-07-09T13:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>记一下常见的一些状态码。<br><a id="more"></a></p>
<ul>
<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>
<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>
<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>
<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>
<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>
<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>
<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>
<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>
<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>
<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>
<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记一下常见的一些状态码。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="http://hunnble.github.io/tag/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python遍历路径解析xml文件</title>
    <link href="http://hunnble.github.io/2016/06/01/Python%E9%81%8D%E5%8E%86%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/"/>
    <id>http://hunnble.github.io/2016/06/01/Python遍历路径解析xml文件/</id>
    <published>2016-06-01T11:38:02.000Z</published>
    <updated>2016-06-21T15:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间没学什么新东西，时间都花在复习考试科目和一个用Flask做的小外包上了，昨天晚上又通知我说有一个数据库的数据人家给的都是xml格式的，需要我写个脚本自己转化成BSON然后存到建好的那个MongoDB数据库里。所以今天上网搜了一下有关的模块看了看，写了一个。<br>如果你知道xml是什么,想知道python怎样解析大的xml文件就继续看下去吧.<br><a id="more"></a><br>在sax和dom这两种方法中我选了前者，这两个分别是什么意思有什么不同呢？简单地说，sax(simple API for XML)用事件驱动模型，通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件,而dom(Document Object Model)是前端er的老熟人了，dom树dom树地叫着，dom就是把xml先一下子解析成一个树结构然后再选标签什么的。<br>所以大文件用sax就好了嘛，一条一条地来肯定比dom的先全部转换成树结构要速度，而且不占内存。<br>当然dom也有它的好，比如写的少了，不用写handler什么的还是比较省心的。总之要根据具体情况选择。<br>首先，我拿到的文件夹是一个大文件夹里面有很多子文件夹，每个子文件夹中有多个xml文档。那么先要实现对路径的遍历和路径下的文件的遍历:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tra_paths</span><span class="params">(path, func)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path):</div><div class="line">        <span class="keyword">print</span> <span class="string">u"Error:' "</span>,path,<span class="string">u"' 不是有效路径"</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    list_dirs = os.walk(path)</div><div class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> list_dirs:</div><div class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dirs:</div><div class="line">            tra_files(os.path.join(root, d), func)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tra_files</span><span class="params">(path, func)</span>:</span></div><div class="line">    files = os.listdir(path)</div><div class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</div><div class="line">        func(path+<span class="string">'/'</span>+file)</div></pre></td></tr></table></figure></p>
<p>用python中的os模块可以很方便，os中的walk函数遍历参数路径下的所有路径，返回值是元组(root, dir, files)，分别是根路径，当前路径和当前路径下的文件。用os.path下的join将根路径和当前路径连成完整路径，然后进入遍历文件的函数。那个func函数就是要对每个文件使用的函数，在这篇博客里当然就是解析xml啦</p>
<h2 id="sax怎样解析xml呢？"><a href="#sax怎样解析xml呢？" class="headerlink" title="sax怎样解析xml呢？"></a>sax怎样解析xml呢？</h2><p>利用SAX解析XML文档牵涉到两个部分:解析器和事件处理器。解析器负责读取XML文档,并向事件处理器发送事件，如元素开始跟元素结束事件，而事件处理器则负责对事件作出相应,对传递的XML数据进行处理。</p>
<h2 id="ContentHandler类方法介绍"><a href="#ContentHandler类方法介绍" class="headerlink" title="ContentHandler类方法介绍"></a>ContentHandler类方法介绍</h2><h4 id="characters-content-方法"><a href="#characters-content-方法" class="headerlink" title="characters(content)方法"></a>characters(content)方法</h4><p>调用时机：<br>从行开始，遇到标签之前，存在字符，content的值为这些字符串。<br>从一个标签，遇到下一个标签之前， 存在字符，content的值为这些字符串。<br>从一个标签，遇到行结束符之前，存在字符，content的值为这些字符串。<br>标签可以是开始标签，也可以是结束标签。</p>
<h4 id="startDocument-方法"><a href="#startDocument-方法" class="headerlink" title="startDocument()方法"></a>startDocument()方法</h4><p>文档启动的时候调用。</p>
<h4 id="endDocument-方法"><a href="#endDocument-方法" class="headerlink" title="endDocument()方法"></a>endDocument()方法</h4><p>解析器到达文档结尾时调用。</p>
<h4 id="startElement-name-attrs-方法"><a href="#startElement-name-attrs-方法" class="headerlink" title="startElement(name, attrs)方法"></a>startElement(name, attrs)方法</h4><p>遇到XML开始标签时调用，name是标签的名字，attrs是标签的属性值字典。</p>
<h4 id="endElement-name-方法"><a href="#endElement-name-方法" class="headerlink" title="endElement(name)方法"></a>endElement(name)方法</h4><p>遇到XML结束标签时调用。</p>
<h2 id="如何使用解析器？"><a href="#如何使用解析器？" class="headerlink" title="如何使用解析器？"></a>如何使用解析器？</h2><p>xml.sax.make_parser([parser_list])方法可以创建一个新的解析器，parser_list是可选参数，指解析器列表<br>xml.sax.parse(xmlfile, contenthandler[, errorhandler])方法解析xml文件，xmlfile是xml文件名，contenthandler是ContentHandler对象，errorhandler是可选参数。<br>xml.sax.parseString(xmlstring, contenthandler[, errorhandler])与parse方法类似，唯一的不同就是第一个参数换成xml字符串。</p>
<p>基本概念说完了，下面看代码，我给出的代码去掉数据库操作，直接打印，看官可以直接拿去改一下路径然后看效果。</p>
<p>首先写一个ContentHandler类:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XML2DB</span><span class="params">(sax.ContentHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.CurrentData = <span class="string">""</span></div><div class="line">        self.id = <span class="string">""</span></div><div class="line">        self.name = <span class="string">""</span></div><div class="line">        self.savepath = <span class="string">""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startElement</span><span class="params">(self, tag, attributes)</span>:</span></div><div class="line">        self.CurrentData = tag</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">endElement</span><span class="params">(self, tag)</span>:</span></div><div class="line">        <span class="keyword">if</span> tag == <span class="string">"ID"</span> <span class="keyword">or</span> tag == <span class="string">"id"</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">"ID:"</span>, self.id</div><div class="line">        <span class="keyword">elif</span> tag == <span class="string">"Name"</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">"Name:"</span>, self.name</div><div class="line">        <span class="keyword">elif</span> tag == <span class="string">"SavePath"</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">"SavePath:"</span>, self.savepath</div><div class="line">        self.CurrentData = <span class="string">""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">characters</span><span class="params">(self, content)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.CurrentData == <span class="string">"ID"</span> <span class="keyword">or</span> self.CurrentData == <span class="string">"id"</span>:</div><div class="line">            self.id = content</div><div class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"Name"</span>:</div><div class="line">            self.name = content</div><div class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"SavePath"</span>:</div><div class="line">            self.savepath = content</div></pre></td></tr></table></figure></p>
<p>我只需要xml中的Name,ID(或者id,这里吐槽一下，我拿到的xml里id这个标签有这两种写法。。。我差点漏了一种。。。)还有SavePath，那就在startElement用CurrentData保存当前标签然后在characters中解析内容(content)再在endElment中输出。很简单。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseXML</span><span class="params">(file)</span>:</span></div><div class="line">    parser = sax.make_parser()</div><div class="line">    changer = XML2DB()</div><div class="line">    parser.setContentHandler(changer)</div><div class="line">    parser.parse(file)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    tra_paths(<span class="string">'./Task'</span>, parseXML)</div></pre></td></tr></table></figure></p>
<p>这就是最后的调用了，新建parser，然后设置ContentHandler为我刚刚写的，然后解析就可以了。main函数中就一句，遍历解析所有文件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间没学什么新东西，时间都花在复习考试科目和一个用Flask做的小外包上了，昨天晚上又通知我说有一个数据库的数据人家给的都是xml格式的，需要我写个脚本自己转化成BSON然后存到建好的那个MongoDB数据库里。所以今天上网搜了一下有关的模块看了看，写了一个。&lt;br&gt;如果你知道xml是什么,想知道python怎样解析大的xml文件就继续看下去吧.&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://hunnble.github.io/tag/python/"/>
    
  </entry>
  
</feed>
